{
  "language": "Solidity",
  "sources": {
    "contracts/burnHelper/BurnGasHelper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport \"./IBurnGasHelper.sol\";\nimport {Utils} from \"../vendor/kyber/utils/Utils.sol\";\nimport {Withdrawable} from \"../vendor/kyber/utils/Withdrawable.sol\";\n\ncontract BurnGasHelper is IBurnGasHelper, Utils, Withdrawable {\n    address public gasTokenAddr;\n\n    constructor(address _admin, address _gasToken) Withdrawable(_admin) {\n        gasTokenAddr = _gasToken;\n    }\n\n    function updateGasToken(address _gasToken) external onlyAdmin {\n        gasTokenAddr = _gasToken;\n    }\n\n    function getAmountGasTokensToBurn(uint256 gasTotalConsumption)\n        external\n        view\n        override\n        returns (uint256 numGas, address gasToken)\n    {\n        gasToken = gasTokenAddr;\n        uint256 gas = gasleft();\n        uint256 safeNumTokens = 0;\n        if (gas >= 27710) {\n            safeNumTokens = (gas - 27710) / 7020; // (1148 + 5722 + 150);\n        }\n\n        uint256 gasSpent = 21000 + 16 * gasTotalConsumption;\n        numGas = (gasSpent + 14154) / 41947;\n\n        numGas = minOf(safeNumTokens, numGas);\n    }\n}\n"
    },
    "contracts/burnHelper/IBurnGasHelper.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IBurnGasHelper {\n    function getAmountGasTokensToBurn(uint256 gasTotalConsumption)\n        external\n        view\n        returns (uint256 numGas, address gasToken);\n}\n"
    },
    "contracts/vendor/kyber/utils/Utils.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport \"../../openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n\n/**\n * @title Kyber utility file\n * mostly shared constants and rate calculation helpers\n * inherited by most of kyber contracts.\n * previous utils implementations are for previous solidity versions.\n */\n// solhint-disable private-vars-leading-underscore\ncontract Utils {\n    // Declared constants below to be used in tandem with\n    // getDecimalsConstant(), for gas optimization purposes\n    // which return decimals from a constant list of popular\n    // tokens.\n    IERC20 internal constant ETH_TOKEN_ADDRESS = IERC20(\n        0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE\n    );\n    IERC20 internal constant USDT_TOKEN_ADDRESS = IERC20(\n        0xdAC17F958D2ee523a2206206994597C13D831ec7\n    );\n    IERC20 internal constant DAI_TOKEN_ADDRESS = IERC20(\n        0x6B175474E89094C44Da98b954EedeAC495271d0F\n    );\n    IERC20 internal constant USDC_TOKEN_ADDRESS = IERC20(\n        0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\n    );\n    IERC20 internal constant WBTC_TOKEN_ADDRESS = IERC20(\n        0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599\n    );\n    IERC20 internal constant KNC_TOKEN_ADDRESS = IERC20(\n        0xdd974D5C2e2928deA5F71b9825b8b646686BD200\n    );\n    uint256 public constant BPS = 10000; // Basic Price Steps. 1 step = 0.01%\n    uint256 internal constant PRECISION = (10**18);\n    uint256 internal constant MAX_QTY = (10**28); // 10B tokens\n    uint256 internal constant MAX_RATE = (PRECISION * 10**7); // up to 10M tokens per eth\n    uint256 internal constant MAX_DECIMALS = 18;\n    uint256 internal constant ETH_DECIMALS = 18;\n    uint256 internal constant MAX_ALLOWANCE = type(uint).max; // token.approve inifinite\n\n    mapping(IERC20 => uint256) internal decimals;\n\n    /// @dev Sets the decimals of a token to storage if not already set, and returns\n    ///      the decimals value of the token. Prefer using this function over\n    ///      getDecimals(), to avoid forgetting to set decimals in local storage.\n    /// @param token The token type\n    /// @return tokenDecimals The decimals of the token\n    function getSetDecimals(IERC20 token) internal returns (uint256 tokenDecimals) {\n        tokenDecimals = getDecimalsConstant(token);\n        if (tokenDecimals > 0) return tokenDecimals;\n\n        tokenDecimals = decimals[token];\n        if (tokenDecimals == 0) {\n            tokenDecimals = token.decimals();\n            decimals[token] = tokenDecimals;\n        }\n    }\n\n    /// @dev Get the balance of a user\n    /// @param token The token type\n    /// @param user The user's address\n    /// @return The balance\n    function getBalance(IERC20 token, address user) internal view returns (uint256) {\n        if (token == ETH_TOKEN_ADDRESS) {\n            return user.balance;\n        } else {\n            return token.balanceOf(user);\n        }\n    }\n\n    /// @dev Get the decimals of a token, read from the constant list, storage,\n    ///      or from token.decimals(). Prefer using getSetDecimals when possible.\n    /// @param token The token type\n    /// @return tokenDecimals The decimals of the token\n    function getDecimals(IERC20 token) internal view returns (uint256 tokenDecimals) {\n        // return token decimals if has constant value\n        tokenDecimals = getDecimalsConstant(token);\n        if (tokenDecimals > 0) return tokenDecimals;\n\n        // handle case where token decimals is not a declared decimal constant\n        tokenDecimals = decimals[token];\n        // moreover, very possible that old tokens have decimals 0\n        // these tokens will just have higher gas fees.\n        return (tokenDecimals > 0) ? tokenDecimals : token.decimals();\n    }\n\n    function calcDestAmount(\n        IERC20 src,\n        IERC20 dest,\n        uint256 srcAmount,\n        uint256 rate\n    ) internal view returns (uint256) {\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\n    }\n\n    function calcSrcAmount(\n        IERC20 src,\n        IERC20 dest,\n        uint256 destAmount,\n        uint256 rate\n    ) internal view returns (uint256) {\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\n    }\n\n    function calcDstQty(\n        uint256 srcQty,\n        uint256 srcDecimals,\n        uint256 dstDecimals,\n        uint256 rate\n    ) internal pure returns (uint256) {\n        require(srcQty <= MAX_QTY, \"srcQty > MAX_QTY\");\n        require(rate <= MAX_RATE, \"rate > MAX_RATE\");\n\n        if (dstDecimals >= srcDecimals) {\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\n        } else {\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\n        }\n    }\n\n    function calcSrcQty(\n        uint256 dstQty,\n        uint256 srcDecimals,\n        uint256 dstDecimals,\n        uint256 rate\n    ) internal pure returns (uint256) {\n        require(dstQty <= MAX_QTY, \"dstQty > MAX_QTY\");\n        require(rate <= MAX_RATE, \"rate > MAX_RATE\");\n\n        //source quantity is rounded up. to avoid dest quantity being too low.\n        uint256 numerator;\n        uint256 denominator;\n        if (srcDecimals >= dstDecimals) {\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\n            denominator = rate;\n        } else {\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\n            numerator = (PRECISION * dstQty);\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\n        }\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\n    }\n\n    function calcRateFromQty(\n        uint256 srcAmount,\n        uint256 destAmount,\n        uint256 srcDecimals,\n        uint256 dstDecimals\n    ) internal pure returns (uint256) {\n        require(srcAmount <= MAX_QTY, \"srcAmount > MAX_QTY\");\n        require(destAmount <= MAX_QTY, \"destAmount > MAX_QTY\");\n\n        if (dstDecimals >= srcDecimals) {\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS, \"dst - src > MAX_DECIMALS\");\n            return ((destAmount * PRECISION) / ((10**(dstDecimals - srcDecimals)) * srcAmount));\n        } else {\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS, \"src - dst > MAX_DECIMALS\");\n            return ((destAmount * PRECISION * (10**(srcDecimals - dstDecimals))) / srcAmount);\n        }\n    }\n\n    /// @dev save storage access by declaring token decimal constants\n    /// @param token The token type\n    /// @return token decimals\n    function getDecimalsConstant(IERC20 token) internal pure returns (uint256) {\n        if (token == ETH_TOKEN_ADDRESS) {\n            return ETH_DECIMALS;\n        } else if (token == USDT_TOKEN_ADDRESS) {\n            return 6;\n        } else if (token == DAI_TOKEN_ADDRESS) {\n            return 18;\n        } else if (token == USDC_TOKEN_ADDRESS) {\n            return 6;\n        } else if (token == WBTC_TOKEN_ADDRESS) {\n            return 8;\n        } else if (token == KNC_TOKEN_ADDRESS) {\n            return 18;\n        } else {\n            return 0;\n        }\n    }\n\n    function minOf(uint256 x, uint256 y) internal pure returns (uint256) {\n        return x > y ? y : x;\n    }\n}"
    },
    "contracts/vendor/kyber/utils/Withdrawable.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {SafeERC20, IERC20} from \"../../openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport \"./PermissionGroups.sol\";\n\ncontract Withdrawable is PermissionGroups {\n    using SafeERC20 for IERC20;\n\n    event TokenWithdraw(IERC20 token, uint256 amount, address sendTo);\n    event EtherWithdraw(uint256 amount, address sendTo);\n\n    // solhint-disable-next-line no-empty-blocks\n    constructor(address _admin) PermissionGroups(_admin) {}\n\n    /**\n     * @dev Withdraw all IERC20 compatible tokens\n     * @param token IERC20 The address of the token contract\n     */\n    function withdrawToken(\n        IERC20 token,\n        uint256 amount,\n        address sendTo\n    ) external onlyAdmin {\n        token.safeTransfer(sendTo, amount);\n        emit TokenWithdraw(token, amount, sendTo);\n    }\n\n    /**\n     * @dev Withdraw Ethers\n     */\n    function withdrawEther(uint256 amount, address payable sendTo) external onlyAdmin {\n        (bool success, ) = sendTo.call{value: amount}(\"\");\n        require(success, \"withdraw failed\");\n        emit EtherWithdraw(amount, sendTo);\n    }\n}"
    },
    "contracts/vendor/openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n\n    function decimals() external view returns (uint8 digits);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount)\n        external\n        returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(\n        address indexed owner,\n        address indexed spender,\n        uint256 value\n    );\n}\n"
    },
    "contracts/vendor/openzeppelin/contracts/token/ERC20/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transfer.selector, to, value)\n        );\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.transferFrom.selector, from, to, value)\n        );\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        // solhint-disable-next-line max-line-length\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(token.approve.selector, spender, value)\n        );\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance =\n            token.allowance(address(this), spender).add(value);\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance =\n            token.allowance(address(this), spender).sub(\n                value,\n                \"SafeERC20: decreased allowance below zero\"\n            );\n        _callOptionalReturn(\n            token,\n            abi.encodeWithSelector(\n                token.approve.selector,\n                spender,\n                newAllowance\n            )\n        );\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata =\n            address(token).functionCall(\n                data,\n                \"SafeERC20: low-level call failed\"\n            );\n        if (returndata.length > 0) {\n            // Return data is optional\n            // solhint-disable-next-line max-line-length\n            require(\n                abi.decode(returndata, (bool)),\n                \"SafeERC20: ERC20 operation did not succeed\"\n            );\n        }\n    }\n}\n"
    },
    "contracts/vendor/kyber/utils/PermissionGroups.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\n// solhint-disable max-states-count\n// solhint-disable private-vars-leading-underscore\ncontract PermissionGroups {\n    uint256 internal constant MAX_GROUP_SIZE = 50;\n\n    address public admin;\n    address public pendingAdmin;\n    mapping(address => bool) internal operators;\n    mapping(address => bool) internal alerters;\n    address[] internal operatorsGroup;\n    address[] internal alertersGroup;\n\n    event AdminClaimed(address newAdmin, address previousAdmin);\n\n    event TransferAdminPending(address pendingAdmin);\n\n    event OperatorAdded(address newOperator, bool isAdd);\n\n    event AlerterAdded(address newAlerter, bool isAdd);\n\n    constructor(address _admin) {\n        require(_admin != address(0), \"admin 0\");\n        admin = _admin;\n    }\n\n    modifier onlyAdmin() {\n        require(msg.sender == admin, \"only admin\");\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(operators[msg.sender], \"only operator\");\n        _;\n    }\n\n    modifier onlyAlerter() {\n        require(alerters[msg.sender], \"only alerter\");\n        _;\n    }\n\n    function getOperators() external view returns (address[] memory) {\n        return operatorsGroup;\n    }\n\n    function getAlerters() external view returns (address[] memory) {\n        return alertersGroup;\n    }\n\n    /**\n     * @dev Allows the current admin to set the pendingAdmin address.\n     * @param newAdmin The address to transfer ownership to.\n     */\n    function transferAdmin(address newAdmin) public onlyAdmin {\n        require(newAdmin != address(0), \"new admin 0\");\n        emit TransferAdminPending(newAdmin);\n        pendingAdmin = newAdmin;\n    }\n\n    /**\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\n     * @param newAdmin The address to transfer ownership to.\n     */\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\n        require(newAdmin != address(0), \"admin 0\");\n        emit TransferAdminPending(newAdmin);\n        emit AdminClaimed(newAdmin, admin);\n        admin = newAdmin;\n    }\n\n    /**\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\n     */\n    function claimAdmin() public {\n        require(pendingAdmin == msg.sender, \"not pending\");\n        emit AdminClaimed(pendingAdmin, admin);\n        admin = pendingAdmin;\n        pendingAdmin = address(0);\n    }\n\n    function addAlerter(address newAlerter) public onlyAdmin {\n        require(!alerters[newAlerter], \"alerter exists\"); // prevent duplicates.\n        require(alertersGroup.length < MAX_GROUP_SIZE, \"max alerters\");\n\n        emit AlerterAdded(newAlerter, true);\n        alerters[newAlerter] = true;\n        alertersGroup.push(newAlerter);\n    }\n\n    function removeAlerter(address alerter) public onlyAdmin {\n        require(alerters[alerter], \"not alerter\");\n        alerters[alerter] = false;\n\n        for (uint256 i = 0; i < alertersGroup.length; ++i) {\n            if (alertersGroup[i] == alerter) {\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\n                alertersGroup.pop();\n                emit AlerterAdded(alerter, false);\n                break;\n            }\n        }\n    }\n\n    function addOperator(address newOperator) public onlyAdmin {\n        require(!operators[newOperator], \"operator exists\"); // prevent duplicates.\n        require(operatorsGroup.length < MAX_GROUP_SIZE, \"max operators\");\n\n        emit OperatorAdded(newOperator, true);\n        operators[newOperator] = true;\n        operatorsGroup.push(newOperator);\n    }\n\n    function removeOperator(address operator) public onlyAdmin {\n        require(operators[operator], \"not operator\");\n        operators[operator] = false;\n\n        for (uint256 i = 0; i < operatorsGroup.length; ++i) {\n            if (operatorsGroup[i] == operator) {\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\n                operatorsGroup.pop();\n                emit OperatorAdded(operator, false);\n                break;\n            }\n        }\n    }\n}"
    },
    "contracts/vendor/openzeppelin/contracts/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/vendor/openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(\n            address(this).balance >= amount,\n            \"Address: insufficient balance\"\n        );\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(\n            success,\n            \"Address: unable to send value, recipient may have reverted\"\n        );\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain`call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data)\n        internal\n        returns (bytes memory)\n    {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return\n            functionCallWithValue(\n                target,\n                data,\n                value,\n                \"Address: low-level call with value failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(\n            address(this).balance >= value,\n            \"Address: insufficient balance for call\"\n        );\n        require(isContract(target), \"Address: call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) =\n            target.call{value: value}(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data)\n        internal\n        view\n        returns (bytes memory)\n    {\n        return\n            functionStaticCall(\n                target,\n                data,\n                \"Address: low-level static call failed\"\n            );\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return _verifyCallResult(success, returndata, errorMessage);\n    }\n\n    function _verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) private pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                // solhint-disable-next-line no-inline-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "contracts/lending/SmartWalletLending.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport \"../interfaces/krystal/ILendingPoolCore.sol\";\nimport \"../interfaces/krystal/IComptroller.sol\";\nimport \"../interfaces/krystal/ISmartWalletLending.sol\";\n\nimport {\n    SafeERC20,\n    IERC20\n} from \"../vendor/openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {\n    SafeMath\n} from \"../vendor/openzeppelin/contracts/math/SafeMath.sol\";\nimport {Utils} from \"../vendor/kyber/utils/Utils.sol\";\nimport {Withdrawable} from \"../vendor/kyber/utils/Withdrawable.sol\";\nimport {\n    ReentrancyGuard\n} from \"../vendor/openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\n// solhint-disable no-empty-blocks\n// solhint-disable function-max-lines\n// solhint-disable code-complexity\n// solhint-disable private-vars-leading-underscore\ncontract SmartWalletLending is ISmartWalletLending, Utils, Withdrawable {\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    struct AaveLendingPoolData {\n        IAaveLendingPoolV2 lendingPoolV2;\n        IProtocolDataProvider provider;\n        mapping(IERC20 => address) aTokensV2;\n        IWeth weth;\n        IAaveLendingPoolV1 lendingPoolV1;\n        mapping(IERC20 => address) aTokensV1;\n        address lendingPoolCoreV1;\n        uint16 referalCode;\n    }\n\n    AaveLendingPoolData public aaveLendingPool;\n\n    struct CompoundData {\n        address comptroller;\n        mapping(IERC20 => address) cTokens;\n    }\n\n    CompoundData public compoundData;\n\n    address public swapImplementation;\n\n    event UpdatedSwapImplementation(\n        address indexed _oldSwapImpl,\n        address indexed _newSwapImpl\n    );\n    event UpdatedAaveLendingPool(\n        IAaveLendingPoolV2 poolV2,\n        IProtocolDataProvider provider,\n        IAaveLendingPoolV1 poolV1,\n        address lendingPoolCoreV1,\n        uint16 referalCode,\n        IWeth weth,\n        IERC20[] tokens,\n        address[] aTokensV1,\n        address[] aTokensV2\n    );\n    event UpdatedCompoudData(\n        address comptroller,\n        address cEth,\n        address[] cTokens,\n        IERC20[] underlyingTokens\n    );\n\n    modifier onlySwapImpl() {\n        require(msg.sender == swapImplementation, \"only swap impl\");\n        _;\n    }\n\n    constructor(address _admin) Withdrawable(_admin) {}\n\n    receive() external payable {}\n\n    function updateSwapImplementation(address _swapImpl) external onlyAdmin {\n        require(_swapImpl != address(0), \"invalid swap impl\");\n        emit UpdatedSwapImplementation(swapImplementation, _swapImpl);\n        swapImplementation = _swapImpl;\n    }\n\n    function updateAaveLendingPoolData(\n        IAaveLendingPoolV2 poolV2,\n        IProtocolDataProvider provider,\n        IAaveLendingPoolV1 poolV1,\n        address lendingPoolCoreV1,\n        uint16 referalCode,\n        IWeth weth,\n        IERC20[] calldata tokens\n    ) external override onlyAdmin {\n        require(weth != IWeth(address(0)), \"invalid weth\");\n        aaveLendingPool.lendingPoolV2 = poolV2;\n        aaveLendingPool.provider = provider;\n        aaveLendingPool.lendingPoolV1 = poolV1;\n        aaveLendingPool.lendingPoolCoreV1 = lendingPoolCoreV1;\n        aaveLendingPool.referalCode = referalCode;\n        aaveLendingPool.weth = weth;\n\n        address[] memory aTokensV1 = new address[](tokens.length);\n        address[] memory aTokensV2 = new address[](tokens.length);\n\n        for (uint256 i = 0; i < tokens.length; i++) {\n            if (poolV1 != IAaveLendingPoolV1(address(0))) {\n                // update data for pool v1\n                try\n                    ILendingPoolCore(poolV1.core()).getReserveATokenAddress(\n                        address(tokens[i])\n                    )\n                returns (address aToken) {\n                    aTokensV1[i] = aToken;\n                } catch {}\n                aaveLendingPool.aTokensV1[tokens[i]] = aTokensV1[i];\n            }\n            if (poolV2 != IAaveLendingPoolV2(address(0))) {\n                address token =\n                    tokens[i] == ETH_TOKEN_ADDRESS\n                        ? address(weth)\n                        : address(tokens[i]);\n                // update data for pool v2\n                try poolV2.getReserveData(token) returns (\n                    DataTypes.ReserveData memory data\n                ) {\n                    aTokensV2[i] = data.aTokenAddress;\n                } catch {}\n                aaveLendingPool.aTokensV2[tokens[i]] = aTokensV2[i];\n            }\n        }\n\n        // do token approvals\n        if (lendingPoolCoreV1 != address(0)) {\n            for (uint256 j = 0; j < aTokensV1.length; j++) {\n                safeApproveAllowance(lendingPoolCoreV1, tokens[j]);\n            }\n        }\n        if (poolV2 != IAaveLendingPoolV2(address(0))) {\n            for (uint256 j = 0; j < aTokensV1.length; j++) {\n                safeApproveAllowance(address(poolV2), tokens[j]);\n            }\n        }\n\n        emit UpdatedAaveLendingPool(\n            poolV2,\n            provider,\n            poolV1,\n            lendingPoolCoreV1,\n            referalCode,\n            weth,\n            tokens,\n            aTokensV1,\n            aTokensV2\n        );\n    }\n\n    function updateCompoundData(\n        address _comptroller,\n        address _cEth,\n        address[] calldata _cTokens\n    ) external override onlyAdmin {\n        require(_comptroller != address(0), \"invalid _comptroller\");\n        require(_cEth != address(0), \"invalid cEth\");\n\n        compoundData.comptroller = _comptroller;\n        compoundData.cTokens[ETH_TOKEN_ADDRESS] = _cEth;\n\n        IERC20[] memory tokens;\n        if (_cTokens.length > 0) {\n            // add specific markets\n            tokens = new IERC20[](_cTokens.length);\n            for (uint256 i = 0; i < _cTokens.length; i++) {\n                require(_cTokens[i] != address(0), \"invalid cToken\");\n                tokens[i] = IERC20(ICompErc20(_cTokens[i]).underlying());\n                require(\n                    tokens[i] != IERC20(address(0)),\n                    \"invalid underlying token\"\n                );\n                compoundData.cTokens[tokens[i]] = _cTokens[i];\n\n                // do token approvals\n                safeApproveAllowance(_cTokens[i], tokens[i]);\n            }\n            emit UpdatedCompoudData(_comptroller, _cEth, _cTokens, tokens);\n        } else {\n            // add all markets\n            ICompErc20[] memory markets =\n                IComptroller(_comptroller).getAllMarkets();\n            tokens = new IERC20[](markets.length);\n            address[] memory cTokens = new address[](markets.length);\n            for (uint256 i = 0; i < markets.length; i++) {\n                if (address(markets[i]) == _cEth) {\n                    tokens[i] = ETH_TOKEN_ADDRESS;\n                    cTokens[i] = _cEth;\n                    continue;\n                }\n                require(markets[i] != ICompErc20(address(0)), \"invalid cToken\");\n                tokens[i] = IERC20(markets[i].underlying());\n                require(\n                    tokens[i] != IERC20(address(0)),\n                    \"invalid underlying token\"\n                );\n                cTokens[i] = address(markets[i]);\n                compoundData.cTokens[tokens[i]] = cTokens[i];\n\n                // do token approvals\n                safeApproveAllowance(_cTokens[i], tokens[i]);\n            }\n            emit UpdatedCompoudData(_comptroller, _cEth, cTokens, tokens);\n        }\n    }\n\n    /// @dev deposit to lending platforms like AAVE, COMPOUND\n    ///     expect amount of token should already be in the contract\n    function depositTo(\n        LendingPlatform platform,\n        address payable onBehalfOf,\n        IERC20 token,\n        uint256 amount\n    ) external override onlySwapImpl {\n        require(getBalance(token, address(this)) >= amount, \"low balance\");\n        if (platform == LendingPlatform.AAVE_V1) {\n            IAaveLendingPoolV1 poolV1 = aaveLendingPool.lendingPoolV1;\n            IERC20 aToken = IERC20(aaveLendingPool.aTokensV1[token]);\n            require(aToken != IERC20(address(0)), \"aToken not found\");\n\n            // deposit and compute received aToken amount\n            uint256 aTokenBalanceBefore = aToken.balanceOf(address(this));\n            poolV1.deposit{value: token == ETH_TOKEN_ADDRESS ? amount : 0}(\n                address(token),\n                amount,\n                aaveLendingPool.referalCode\n            );\n            uint256 aTokenBalanceAfter = aToken.balanceOf(address(this));\n            // transfer all received aToken back to the sender\n            aToken.safeTransfer(\n                onBehalfOf,\n                aTokenBalanceAfter.sub(aTokenBalanceBefore)\n            );\n        } else if (platform == LendingPlatform.AAVE_V2) {\n            if (token == ETH_TOKEN_ADDRESS) {\n                // wrap eth -> weth, then deposit\n                IWeth weth = aaveLendingPool.weth;\n                IAaveLendingPoolV2 pool = aaveLendingPool.lendingPoolV2;\n                weth.deposit{value: amount}();\n                pool.deposit(\n                    address(weth),\n                    amount,\n                    onBehalfOf,\n                    aaveLendingPool.referalCode\n                );\n            } else {\n                IAaveLendingPoolV2 pool = aaveLendingPool.lendingPoolV2;\n                pool.deposit(\n                    address(token),\n                    amount,\n                    onBehalfOf,\n                    aaveLendingPool.referalCode\n                );\n            }\n        } else {\n            // Compound\n            address cToken = compoundData.cTokens[token];\n            require(cToken != address(0), \"token is not supported by Compound\");\n            uint256 cTokenBalanceBefore =\n                IERC20(cToken).balanceOf(address(this));\n            if (token == ETH_TOKEN_ADDRESS) {\n                ICompEth(cToken).mint{value: amount}();\n            } else {\n                require(\n                    ICompErc20(cToken).mint(amount) == 0,\n                    \"can not mint cToken\"\n                );\n            }\n            uint256 cTokenBalanceAfter =\n                IERC20(cToken).balanceOf(address(this));\n            IERC20(cToken).safeTransfer(\n                onBehalfOf,\n                cTokenBalanceAfter.sub(cTokenBalanceBefore)\n            );\n        }\n    }\n\n    /// @dev borrow from lending platforms like AAVE v2, COMPOUND\n    function borrowFrom(\n        LendingPlatform platform,\n        address payable onBehalfOf,\n        IERC20 token,\n        uint256 borrowAmount,\n        uint256 interestRateMode\n    ) external override onlySwapImpl {\n        require(platform != LendingPlatform.AAVE_V1, \"Aave V1 not supported\");\n\n        if (platform == LendingPlatform.AAVE_V2) {\n            IAaveLendingPoolV2 poolV2 = aaveLendingPool.lendingPoolV2;\n            poolV2.borrow(\n                address(token),\n                borrowAmount,\n                interestRateMode,\n                aaveLendingPool.referalCode,\n                onBehalfOf\n            );\n        }\n    }\n\n    /// @dev withdraw from lending platforms like AAVE, COMPOUND\n    ///     expect amount of aToken or cToken should already be in the contract\n    function withdrawFrom(\n        LendingPlatform platform,\n        address payable onBehalfOf,\n        IERC20 token,\n        uint256 amount,\n        uint256 minReturn\n    ) external override onlySwapImpl returns (uint256 returnedAmount) {\n        address lendingToken = getLendingToken(platform, token);\n\n        uint256 tokenBalanceBefore;\n        uint256 tokenBalanceAfter;\n        if (platform == LendingPlatform.AAVE_V1) {\n            // burn aToken to withdraw underlying token\n            tokenBalanceBefore = getBalance(token, address(this));\n            IAToken(lendingToken).redeem(amount);\n            tokenBalanceAfter = getBalance(token, address(this));\n            returnedAmount = tokenBalanceAfter.sub(tokenBalanceBefore);\n            require(returnedAmount >= minReturn, \"low returned amount\");\n            // transfer token to user\n            transferToken(onBehalfOf, token, returnedAmount);\n        } else if (platform == LendingPlatform.AAVE_V2) {\n            if (token == ETH_TOKEN_ADDRESS) {\n                // withdraw weth, then convert to eth for user\n                address weth = address(aaveLendingPool.weth);\n                // withdraw underlying token from pool\n                tokenBalanceBefore = IERC20(weth).balanceOf(address(this));\n                returnedAmount = aaveLendingPool.lendingPoolV2.withdraw(\n                    weth,\n                    amount,\n                    address(this)\n                );\n                tokenBalanceAfter = IERC20(weth).balanceOf(address(this));\n                require(\n                    tokenBalanceAfter.sub(tokenBalanceBefore) >= returnedAmount,\n                    \"invalid return\"\n                );\n                require(returnedAmount >= minReturn, \"low returned amount\");\n                // convert weth to eth and transfer to sender\n                IWeth(weth).withdraw(returnedAmount);\n                (bool success, ) = onBehalfOf.call{value: returnedAmount}(\"\");\n                require(success, \"transfer eth to sender failed\");\n            } else {\n                // withdraw token directly to user's wallet\n                tokenBalanceBefore = getBalance(token, onBehalfOf);\n                returnedAmount = aaveLendingPool.lendingPoolV2.withdraw(\n                    address(token),\n                    amount,\n                    onBehalfOf\n                );\n                tokenBalanceAfter = getBalance(token, onBehalfOf);\n                // valid received amount in user's wallet\n                require(\n                    tokenBalanceAfter.sub(tokenBalanceBefore) >= returnedAmount,\n                    \"invalid return\"\n                );\n                require(returnedAmount >= minReturn, \"low returned amount\");\n            }\n        } else {\n            // COMPOUND\n            // burn cToken to withdraw underlying token\n            tokenBalanceBefore = getBalance(token, address(this));\n            require(\n                ICompErc20(lendingToken).redeem(amount) == 0,\n                \"unable to redeem\"\n            );\n            tokenBalanceAfter = getBalance(token, address(this));\n            returnedAmount = tokenBalanceAfter.sub(tokenBalanceBefore);\n            require(returnedAmount >= minReturn, \"low returned amount\");\n            // transfer underlying token to user\n            transferToken(onBehalfOf, token, returnedAmount);\n        }\n    }\n\n    /// @dev repay borrows to lending platforms like AAVE, COMPOUND\n    ///     expect amount of token should already be in the contract\n    ///     if amount > payAmount, (amount - payAmount) will be sent back to user\n    function repayBorrowTo(\n        LendingPlatform platform,\n        address payable onBehalfOf,\n        IERC20 token,\n        uint256 amount,\n        uint256 payAmount,\n        uint256 rateMode // only for aave v2\n    ) external override onlySwapImpl {\n        require(amount >= payAmount, \"invalid pay amount\");\n        require(\n            getBalance(token, address(this)) >= amount,\n            \"bad token balance\"\n        );\n\n        if (amount > payAmount) {\n            // transfer back token\n            transferToken(payable(onBehalfOf), token, amount - payAmount);\n        }\n        if (platform == LendingPlatform.AAVE_V1) {\n            IAaveLendingPoolV1 poolV1 = aaveLendingPool.lendingPoolV1;\n\n            poolV1.repay{value: token == ETH_TOKEN_ADDRESS ? payAmount : 0}(\n                address(token),\n                payAmount,\n                onBehalfOf\n            );\n        } else if (platform == LendingPlatform.AAVE_V2) {\n            IAaveLendingPoolV2 poolV2 = aaveLendingPool.lendingPoolV2;\n            if (token == ETH_TOKEN_ADDRESS) {\n                IWeth weth = aaveLendingPool.weth;\n                weth.deposit{value: payAmount}();\n                require(\n                    poolV2.repay(\n                        address(weth),\n                        payAmount,\n                        rateMode,\n                        onBehalfOf\n                    ) == payAmount,\n                    \"wrong paid amount\"\n                );\n            } else {\n                require(\n                    poolV2.repay(\n                        address(token),\n                        payAmount,\n                        rateMode,\n                        onBehalfOf\n                    ) == payAmount,\n                    \"wrong paid amount\"\n                );\n            }\n        } else {\n            // compound\n            address cToken = compoundData.cTokens[token];\n            require(cToken != address(0), \"token is not supported by Compound\");\n            if (token == ETH_TOKEN_ADDRESS) {\n                ICompEth(cToken).repayBorrowBehalf{value: payAmount}(\n                    onBehalfOf\n                );\n            } else {\n                require(\n                    ICompErc20(cToken).repayBorrowBehalf(\n                        onBehalfOf,\n                        payAmount\n                    ) == 0,\n                    \"compound repay error\"\n                );\n            }\n        }\n    }\n\n    function claimComp(\n        address[] calldata holders,\n        ICompErc20[] calldata cTokens,\n        bool borrowers,\n        bool suppliers\n    ) external override onlySwapImpl {\n        require(holders.length > 0, \"no holders\");\n        IComptroller comptroller = IComptroller(compoundData.comptroller);\n        if (cTokens.length == 0) {\n            // claim for all markets\n            ICompErc20[] memory markets = comptroller.getAllMarkets();\n            comptroller.claimComp(holders, markets, borrowers, suppliers);\n        } else {\n            comptroller.claimComp(holders, cTokens, borrowers, suppliers);\n        }\n        emit ClaimedComp(holders, cTokens, borrowers, suppliers);\n    }\n\n    function getLendingToken(LendingPlatform platform, IERC20 token)\n        public\n        view\n        override\n        returns (address)\n    {\n        if (platform == LendingPlatform.AAVE_V1) {\n            return aaveLendingPool.aTokensV1[token];\n        } else if (platform == LendingPlatform.AAVE_V2) {\n            return aaveLendingPool.aTokensV2[token];\n        }\n        return compoundData.cTokens[token];\n    }\n\n    /** @dev Calculate the current user debt and return\n     */\n    function storeAndRetrieveUserDebtCurrent(\n        LendingPlatform platform,\n        address _reserve,\n        address _user\n    ) external override returns (uint256 debt) {\n        if (\n            platform == LendingPlatform.AAVE_V1 ||\n            platform == LendingPlatform.AAVE_V2\n        ) {\n            debt = getUserDebtStored(platform, _reserve, _user);\n            return debt;\n        }\n        ICompErc20 cToken = ICompErc20(compoundData.cTokens[IERC20(_reserve)]);\n        debt = cToken.borrowBalanceCurrent(_user);\n    }\n\n    /** @dev Return the stored user debt from given platform\n     *   to get the latest data of user's debt for repaying, should call\n     *   storeAndRetrieveUserDebtCurrent function, esp for Compound platform\n     */\n    function getUserDebtStored(\n        LendingPlatform platform,\n        address _reserve,\n        address _user\n    ) public view override returns (uint256 debt) {\n        if (platform == LendingPlatform.AAVE_V1) {\n            uint256 originationFee;\n            IAaveLendingPoolV1 pool = aaveLendingPool.lendingPoolV1;\n            (, debt, , , , , originationFee, , , ) = pool.getUserReserveData(\n                _reserve,\n                _user\n            );\n            debt = debt.add(originationFee);\n        } else if (platform == LendingPlatform.AAVE_V2) {\n            IProtocolDataProvider provider = aaveLendingPool.provider;\n            (, uint256 stableDebt, uint256 variableDebt, , , , , , ) =\n                provider.getUserReserveData(_reserve, _user);\n            debt = stableDebt > 0 ? stableDebt : variableDebt;\n        } else {\n            ICompErc20 cToken =\n                ICompErc20(compoundData.cTokens[IERC20(_reserve)]);\n            debt = cToken.borrowBalanceStored(_user);\n        }\n    }\n\n    function safeApproveAllowance(address spender, IERC20 token) internal {\n        if (\n            token != ETH_TOKEN_ADDRESS &&\n            token.allowance(address(this), spender) == 0\n        ) {\n            token.safeApprove(spender, MAX_ALLOWANCE);\n        }\n    }\n\n    function transferToken(\n        address payable recipient,\n        IERC20 token,\n        uint256 amount\n    ) internal {\n        if (token == ETH_TOKEN_ADDRESS) {\n            (bool success, ) = recipient.call{value: amount}(\"\");\n            require(success, \"failed to transfer eth\");\n        } else {\n            token.safeTransfer(recipient, amount);\n        }\n    }\n}\n"
    },
    "contracts/interfaces/krystal/ILendingPoolCore.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface ILendingPoolCore {\n    function getReserveATokenAddress(address _reserve)\n        external\n        view\n        returns (address);\n\n    function getReserveTotalLiquidity(address _reserve)\n        external\n        view\n        returns (uint256);\n\n    function getReserveAvailableLiquidity(address _reserve)\n        external\n        view\n        returns (uint256);\n\n    function getReserveCurrentLiquidityRate(address _reserve)\n        external\n        view\n        returns (uint256);\n\n    function getReserveUtilizationRate(address _reserve)\n        external\n        view\n        returns (uint256);\n\n    function getReserveTotalBorrowsStable(address _reserve)\n        external\n        view\n        returns (uint256);\n\n    function getReserveTotalBorrowsVariable(address _reserve)\n        external\n        view\n        returns (uint256);\n\n    function getReserveCurrentVariableBorrowRate(address _reserve)\n        external\n        view\n        returns (uint256);\n\n    function getReserveCurrentStableBorrowRate(address _reserve)\n        external\n        view\n        returns (uint256);\n\n    // solhint-disable max-line-length\n    function getReserveCurrentAverageStableBorrowRate(address _reserve)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "contracts/interfaces/krystal/IComptroller.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport \"./ICompErc20.sol\";\n\ninterface IComptroller {\n    function claimComp(\n        address[] calldata holders,\n        ICompErc20[] calldata cTokens,\n        bool borrowers,\n        bool suppliers\n    ) external;\n\n    function getAllMarkets() external view returns (ICompErc20[] memory);\n\n    function getCompAddress() external view returns (address);\n}\n"
    },
    "contracts/interfaces/krystal/ISmartWalletLending.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    IERC20\n} from \"../../vendor/openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"./IAaveLendingPoolV2.sol\";\nimport \"./IAaveLendingPoolV1.sol\";\nimport \"./IWeth.sol\";\nimport \"./ICompErc20.sol\";\n\ninterface ISmartWalletLending {\n    event ClaimedComp(\n        address[] holders,\n        ICompErc20[] cTokens,\n        bool borrowers,\n        bool suppliers\n    );\n\n    enum LendingPlatform {AAVE_V1, AAVE_V2, COMPOUND}\n\n    struct UserReserveData {\n        uint256 currentATokenBalance;\n        uint256 liquidityRate;\n        uint256 poolShareInPrecision;\n        bool usageAsCollateralEnabled;\n        // Aave v1 data\n        uint256 currentBorrowBalance;\n        uint256 principalBorrowBalance;\n        uint256 borrowRateMode;\n        uint256 borrowRate;\n        uint256 originationFee;\n        // Aave v2 data\n        uint256 currentStableDebt;\n        uint256 currentVariableDebt;\n        uint256 principalStableDebt;\n        uint256 scaledVariableDebt;\n        uint256 stableBorrowRate;\n    }\n\n    function updateAaveLendingPoolData(\n        IAaveLendingPoolV2 poolV2,\n        IProtocolDataProvider provider,\n        IAaveLendingPoolV1 poolV1,\n        address lendingPoolCoreV1,\n        uint16 referalCode,\n        IWeth weth,\n        IERC20[] calldata tokens\n    ) external;\n\n    function updateCompoundData(\n        address _comptroller,\n        address _cEth,\n        address[] calldata _cTokens\n    ) external;\n\n    function depositTo(\n        LendingPlatform platform,\n        address payable onBehalfOf,\n        IERC20 token,\n        uint256 amount\n    ) external;\n\n    function borrowFrom(\n        LendingPlatform platform,\n        address payable onBehalfOf,\n        IERC20 token,\n        uint256 borrowAmount,\n        uint256 interestRateMode\n    ) external;\n\n    function withdrawFrom(\n        LendingPlatform platform,\n        address payable onBehalfOf,\n        IERC20 token,\n        uint256 amount,\n        uint256 minReturn\n    ) external returns (uint256 returnedAmount);\n\n    function repayBorrowTo(\n        LendingPlatform platform,\n        address payable onBehalfOf,\n        IERC20 token,\n        uint256 amount,\n        uint256 payAmount,\n        uint256 rateMode // only for aave v2\n    ) external;\n\n    function claimComp(\n        address[] calldata holders,\n        ICompErc20[] calldata cTokens,\n        bool borrowers,\n        bool suppliers\n    ) external;\n\n    function storeAndRetrieveUserDebtCurrent(\n        LendingPlatform platform,\n        address _reserve,\n        address _user\n    ) external returns (uint256 debt);\n\n    function getLendingToken(LendingPlatform platform, IERC20 token)\n        external\n        view\n        returns (address);\n\n    function getUserDebtStored(\n        LendingPlatform platform,\n        address reserve,\n        address user\n    ) external view returns (uint256 debt);\n}\n"
    },
    "contracts/vendor/openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor () {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and make it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}"
    },
    "contracts/interfaces/krystal/ICompErc20.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface ICompErc20 {\n    function mint(uint256 mintAmount) external returns (uint256);\n\n    function redeem(uint256 redeemTokens) external returns (uint256);\n\n    function redeemUnderlying(uint256 redeemAmount) external returns (uint256);\n\n    function borrow(uint256 borrowAmount) external returns (uint256);\n\n    function repayBorrow(uint256 repayAmount) external returns (uint256);\n\n    function repayBorrowBehalf(address borrower, uint256 repayAmount)\n        external\n        returns (uint256);\n\n    function transfer(address dst, uint256 amount) external returns (bool);\n\n    function transferFrom(\n        address src,\n        address dst,\n        uint256 amount\n    ) external returns (bool);\n\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    function allowance(address owner, address spender)\n        external\n        view\n        returns (uint256);\n\n    function balanceOf(address owner) external view returns (uint256);\n\n    function balanceOfUnderlying(address owner) external returns (uint256);\n\n    function getAccountSnapshot(address account)\n        external\n        view\n        returns (\n            uint256,\n            uint256,\n            uint256,\n            uint256\n        );\n\n    function totalBorrowsCurrent() external returns (uint256);\n\n    function borrowBalanceCurrent(address account) external returns (uint256);\n\n    function borrowBalanceStored(address account)\n        external\n        view\n        returns (uint256);\n\n    function exchangeRateCurrent() external returns (uint256);\n\n    function exchangeRateStored() external view returns (uint256);\n\n    function underlying() external view returns (address);\n}\n\ninterface ICompEth {\n    function mint() external payable;\n\n    function repayBorrowBehalf(address borrower) external payable;\n\n    function repayBorrow() external payable;\n}\n"
    },
    "contracts/interfaces/krystal/IAaveLendingPoolV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport \"./DataTypes.sol\";\nimport \"./IProtocolDataProvider.sol\";\n\n// solhint-disable max-line-length\ninterface IAaveLendingPoolV2 {\n    /**\n     * @dev Deposits an `amount` of underlying asset into the reserve, receiving in return overlying aTokens.\n     * - E.g. User deposits 100 USDC and gets in return 100 aUSDC\n     * @param asset The address of the underlying asset to deposit\n     * @param amount The amount to be deposited\n     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user\n     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens\n     *   is a different wallet\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     **/\n    function deposit(\n        address asset,\n        uint256 amount,\n        address onBehalfOf,\n        uint16 referralCode\n    ) external;\n\n    /**\n     * @dev Withdraws an `amount` of underlying asset from the reserve, burning the equivalent aTokens owned\n     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC\n     * @param asset The address of the underlying asset to withdraw\n     * @param amount The underlying amount to be withdrawn\n     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance\n     * @param to Address that will receive the underlying, same as msg.sender if the user\n     *   wants to receive it on his own wallet, or a different address if the beneficiary is a\n     *   different wallet\n     * @return The final amount withdrawn\n     **/\n    function withdraw(\n        address asset,\n        uint256 amount,\n        address to\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows users to borrow a specific `amount` of the reserve underlying asset, provided that the borrower\n     * already deposited enough collateral, or he was given enough allowance by a credit delegator on the\n     * corresponding debt token (StableDebtToken or VariableDebtToken)\n     * - E.g. User borrows 100 USDC passing as `onBehalfOf` his own address, receiving the 100 USDC in his wallet\n     *   and 100 stable/variable debt tokens, depending on the `interestRateMode`\n     * @param asset The address of the underlying asset to borrow\n     * @param amount The amount to be borrowed\n     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable\n     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.\n     *   0 if the action is executed directly by the user, without any middle-man\n     * @param onBehalfOf Address of the user who will receive the debt. Should be the address of the borrower itself\n     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator\n     * if he has been given credit delegation allowance\n     **/\n    function borrow(\n        address asset,\n        uint256 amount,\n        uint256 interestRateMode,\n        uint16 referralCode,\n        address onBehalfOf\n    ) external;\n\n    /**\n     * @notice Repays a borrowed `amount` on a specific reserve, burning the equivalent debt tokens owned\n     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the `onBehalfOf` address\n     * @param asset The address of the borrowed underlying asset previously borrowed\n     * @param amount The amount to repay\n     * - Send the value type(uint256).max in order to repay the whole debt for `asset` on the specific `debtMode`\n     * @param rateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable\n     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the\n     * user calling the function if he wants to reduce/remove his own debt, or the address of any other\n     * other borrower whose debt should be removed\n     * @return The final amount repaid\n     **/\n    function repay(\n        address asset,\n        uint256 amount,\n        uint256 rateMode,\n        address onBehalfOf\n    ) external returns (uint256);\n\n    /**\n     * @dev Allows depositors to enable/disable a specific deposited asset as collateral\n     * @param asset The address of the underlying asset deposited\n     * @param useAsCollateral `true` if the user wants to use the deposit as collateral, `false` otherwise\n     **/\n    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral)\n        external;\n\n    /**\n     * @dev Returns the state and configuration of the reserve\n     * @param asset The address of the underlying asset of the reserve\n     * @return The state of the reserve\n     **/\n    function getReserveData(address asset)\n        external\n        view\n        returns (DataTypes.ReserveData memory);\n}\n"
    },
    "contracts/interfaces/krystal/IAaveLendingPoolV1.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IAaveLendingPoolV1 {\n    function deposit(\n        address _reserve,\n        uint256 _amount,\n        uint16 _referralCode\n    ) external payable;\n\n    function borrow(\n        address _reserve,\n        uint256 _amount,\n        uint256 _interestRateMode,\n        uint16 _referralCode\n    ) external;\n\n    function setUserUseReserveAsCollateral(\n        address _reserve,\n        bool _useAsCollateral\n    ) external;\n\n    function repay(\n        address _reserve,\n        uint256 _amount,\n        address payable _onBehalfOf\n    ) external payable;\n\n    function core() external view returns (address);\n\n    function getUserReserveData(address _reserve, address _user)\n        external\n        view\n        returns (\n            uint256 currentATokenBalance,\n            uint256 currentBorrowBalance,\n            uint256 principalBorrowBalance,\n            uint256 borrowRateMode,\n            uint256 borrowRate,\n            uint256 liquidityRate,\n            uint256 originationFee,\n            uint256 variableBorrowIndex,\n            uint256 lastUpdateTimestamp,\n            bool usageAsCollateralEnabled\n        );\n}\n\ninterface IAToken {\n    function redeem(uint256 _amount) external;\n}\n"
    },
    "contracts/interfaces/krystal/IWeth.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    IERC20\n} from \"../../vendor/openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IWeth is IERC20 {\n    function deposit() external payable;\n\n    function withdraw(uint256 wad) external;\n}\n"
    },
    "contracts/interfaces/krystal/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nlibrary DataTypes {\n    struct ReserveData {\n        //stores the reserve configuration\n        ReserveConfigurationMap configuration;\n        //the liquidity index. Expressed in ray\n        uint128 liquidityIndex;\n        //variable borrow index. Expressed in ray\n        uint128 variableBorrowIndex;\n        //the current supply rate. Expressed in ray\n        uint128 currentLiquidityRate;\n        //the current variable borrow rate. Expressed in ray\n        uint128 currentVariableBorrowRate;\n        //the current stable borrow rate. Expressed in ray\n        uint128 currentStableBorrowRate;\n        uint40 lastUpdateTimestamp;\n        //tokens addresses\n        address aTokenAddress;\n        address stableDebtTokenAddress;\n        address variableDebtTokenAddress;\n        //address of the interest rate strategy\n        address interestRateStrategyAddress;\n        //the id of the reserve. Represents the position in the list of the active reserves\n        uint8 id;\n    }\n\n    struct ReserveConfigurationMap {\n        //bit 0-15: LTV\n        //bit 16-31: Liq. threshold\n        //bit 32-47: Liq. bonus\n        //bit 48-55: Decimals\n        //bit 56: Reserve is active\n        //bit 57: reserve is frozen\n        //bit 58: borrowing is enabled\n        //bit 59: stable rate borrowing enabled\n        //bit 60-63: reserved\n        //bit 64-79: reserve factor\n        uint256 data;\n    }\n\n    struct UserConfigurationMap {\n        uint256 data;\n    }\n\n    enum InterestRateMode {NONE, STABLE, VARIABLE}\n}\n"
    },
    "contracts/interfaces/krystal/IProtocolDataProvider.sol": {
      "content": "// SPDX-License-Identifier: agpl-3.0\npragma solidity 0.8.0;\n\ninterface IProtocolDataProvider {\n    struct TokenData {\n        string symbol;\n        address tokenAddress;\n    }\n\n    function getAllReservesTokens() external view returns (TokenData[] memory);\n\n    function getAllATokens() external view returns (TokenData[] memory);\n\n    function getReserveConfigurationData(address asset)\n        external\n        view\n        returns (\n            uint256 decimals,\n            uint256 ltv,\n            uint256 liquidationThreshold,\n            uint256 liquidationBonus,\n            uint256 reserveFactor,\n            bool usageAsCollateralEnabled,\n            bool borrowingEnabled,\n            bool stableBorrowRateEnabled,\n            bool isActive,\n            bool isFrozen\n        );\n\n    function getReserveData(address asset)\n        external\n        view\n        returns (\n            uint256 availableLiquidity,\n            uint256 totalStableDebt,\n            uint256 totalVariableDebt,\n            uint256 liquidityRate,\n            uint256 variableBorrowRate,\n            uint256 stableBorrowRate,\n            uint256 averageStableBorrowRate,\n            uint256 liquidityIndex,\n            uint256 variableBorrowIndex,\n            uint40 lastUpdateTimestamp\n        );\n\n    function getUserReserveData(address asset, address user)\n        external\n        view\n        returns (\n            uint256 currentATokenBalance,\n            uint256 currentStableDebt,\n            uint256 currentVariableDebt,\n            uint256 principalStableDebt,\n            uint256 scaledVariableDebt,\n            uint256 stableBorrowRate,\n            uint256 liquidityRate,\n            uint40 stableRateLastUpdated,\n            bool usageAsCollateralEnabled\n        );\n\n    function getReserveTokensAddresses(address asset)\n        external\n        view\n        returns (\n            address aTokenAddress,\n            address stableDebtTokenAddress,\n            address variableDebtTokenAddress\n        );\n\n    function calculateUserGlobalData(address _user)\n        external\n        view\n        returns (\n            uint256 totalLiquidityBalanceETH,\n            uint256 totalCollateralBalanceETH,\n            uint256 totalBorrowBalanceETH,\n            uint256 totalFeesETH,\n            uint256 currentLtv,\n            uint256 currentLiquidationThreshold,\n            uint256 healthFactor,\n            bool healthFactorBelowThreshold\n        );\n}\n"
    },
    "contracts/GelatoKrystal.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    ISmartWalletSwapImplementation\n} from \"./interfaces/krystal/ISmartWalletSwapImplementation.sol\";\nimport {wdiv} from \"./vendor/DSMath.sol\";\nimport {\n    IERC20,\n    SafeERC20\n} from \"./vendor/openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {\n    ReentrancyGuard\n} from \"./vendor/openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Utils} from \"./vendor/kyber/utils/Utils.sol\";\nimport {IKyberProxy} from \"./vendor/kyber/utils/IKyberProxy.sol\";\nimport {\n    IChainlinkOracle\n} from \"./interfaces/chainlink/IChainlinkOracle.sol\";\nimport {IOracleAggregator} from \"./interfaces/gelato/IOracleAggregator.sol\";\nimport {ITaskStorage} from \"./interfaces/gelato/ITaskStorage.sol\";\nimport {\n    IUniswapV2Router02\n} from \"./interfaces/uniswap/IUniswapV2Router02.sol\";\nimport {_to18Decimals} from \"./gelato/functions/FToken.sol\";\nimport {SimpleServiceStandard} from \"./gelato/standards/SimpleServiceStandard.sol\";\nimport {_transferEthOrToken} from \"./gelato/functions/FPayment.sol\";\nimport {ETH} from \"./gelato/constants/CTokens.sol\";\nimport {Fee} from \"./gelato/structs/SGelato.sol\";\nimport {IGelato} from \"./interfaces/gelato/IGelato.sol\";\n\ncontract GelatoKrystal is SimpleServiceStandard, ReentrancyGuard {\n    using SafeERC20 for IERC20;\n\n    struct SubmitOrder {\n        address inToken;\n        address outToken;\n        uint256 amountPerTrade;\n        uint256 numTrades;\n        uint256 minSlippage;\n        uint256 maxSlippage;\n        uint256 delay;\n        address platformWallet;\n        uint256 platformFeeBps;\n    }\n\n    struct ExecOrder {\n        address user;\n        address inToken;\n        address outToken;\n        uint256 amountPerTrade;\n        uint256 nTradesLeft;\n        uint256 minSlippage;\n        uint256 maxSlippage;\n        uint256 delay;\n        uint256 lastExecutionTime;\n        address platformWallet;\n        uint256 platformFeeBps;\n    }\n\n    enum Dex {KYBER, UNISWAP, SUSHISWAP}\n\n    bytes public constant HINT = \"\";\n    uint256 public constant TOTAL_BPS = 10000;\n\n    ISmartWalletSwapImplementation public immutable smartWalletSwap;\n    IUniswapV2Router02 public immutable uniRouterV2;\n    IUniswapV2Router02 public immutable sushiRouterV2;\n\n    event LogTaskSubmitted(uint256 indexed id, ExecOrder order);\n    event LogTaskCancelled(uint256 indexed id, ExecOrder order);\n    event LogTaskUpdated(uint256 indexed id, ExecOrder order);\n    event LogKrystalTrade(\n        uint256 indexed id,\n        ExecOrder order,\n        uint256 amountOut\n    );\n\n    constructor(\n        ISmartWalletSwapImplementation _smartWalletSwap,\n        IUniswapV2Router02 _uniRouterV2,\n        IUniswapV2Router02 _sushiRouterV2,\n        address _gelato\n    ) SimpleServiceStandard(_gelato) {\n        smartWalletSwap = _smartWalletSwap;\n        uniRouterV2 = _uniRouterV2;\n        sushiRouterV2 = _sushiRouterV2;\n    }\n\n    function submit(SubmitOrder memory _order, bool isSubmitAndExec)\n        public\n        payable\n    {\n        if (_order.inToken == ETH) {\n            uint256 value =\n                isSubmitAndExec\n                    ? _order.amountPerTrade * (_order.numTrades + 1)\n                    : _order.amountPerTrade * _order.numTrades;\n            require(\n                msg.value == value,\n                \"GelatoDCA.submit: mismatching amount of ETH deposited\"\n            );\n        }\n        ExecOrder memory order =\n            ExecOrder({\n                user: msg.sender,\n                inToken: _order.inToken,\n                outToken: _order.outToken,\n                amountPerTrade: _order.amountPerTrade,\n                nTradesLeft: _order.numTrades,\n                minSlippage: _order.minSlippage,\n                maxSlippage: _order.maxSlippage,\n                delay: _order.delay, // solhint-disable-next-line not-rely-on-time\n                lastExecutionTime: block.timestamp,\n                platformWallet: _order.platformWallet,\n                platformFeeBps: _order.platformFeeBps\n            });\n\n        // store order\n        _storeOrder(order);\n    }\n\n    // solhint-disable-next-line function-max-lines\n    function submitAndExec(\n        SubmitOrder memory _order,\n        Dex _protocol,\n        uint256 _minReturnOrRate,\n        address[] calldata _tradePath\n    ) external payable {\n        require(\n            _order.numTrades > 1,\n            \"GelatoDCA.submitAndExec: cycle must have 2 or more trades\"\n        );\n\n        // 1. Submit future orders\n        _order.numTrades = _order.numTrades - 1;\n        submit(_order, true);\n\n        // 2. Exec 1st Trade now\n        uint256 ethToSend;\n        if (_order.inToken == ETH) {\n            ethToSend = _order.amountPerTrade;\n        } else {\n            IERC20(_order.inToken).safeTransferFrom(\n                msg.sender,\n                address(this),\n                _order.amountPerTrade\n            );\n            IERC20(_order.inToken).safeIncreaseAllowance(\n                address(smartWalletSwap),\n                _order.amountPerTrade\n            );\n        }\n\n        if (_protocol == Dex.KYBER) {\n            _doKyberTrade(\n                _order.inToken,\n                _order.outToken,\n                _order.amountPerTrade,\n                _minReturnOrRate,\n                payable(msg.sender),\n                ethToSend,\n                _order.platformWallet,\n                _order.platformFeeBps\n            );\n        } else {\n            _doUniTrade(\n                _protocol == Dex.UNISWAP ? uniRouterV2 : sushiRouterV2,\n                _tradePath,\n                _order.amountPerTrade,\n                _minReturnOrRate,\n                payable(msg.sender),\n                ethToSend,\n                _order.platformWallet,\n                _order.platformFeeBps\n            );\n        }\n    }\n\n    function cancel(ExecOrder calldata _order, uint256 _id)\n        external\n        nonReentrant\n    {\n        _removeTask(abi.encode(_order), _id, msg.sender);\n        if (_order.inToken == ETH) {\n            uint256 refundAmount = _order.amountPerTrade * _order.nTradesLeft;\n            (bool success, ) = _order.user.call{value: refundAmount}(\"\");\n            require(success, \"GelatoKrystal.cancel: refund reverted\");\n        }\n\n        emit LogTaskCancelled(_id, _order);\n    }\n\n    // solhint-disable-next-line function-max-lines\n    function editNumTrades(\n        ExecOrder calldata _order,\n        uint256 _id,\n        uint256 _newNumTradesLeft\n    ) external payable nonReentrant {\n        require(\n            _order.nTradesLeft != _newNumTradesLeft,\n            \"GelatoKrystal.editNumTrades: order does not need update\"\n        );\n        require(_newNumTradesLeft > 0, \"GelatoDCA.editNumTrades: cannot be 0\");\n        ExecOrder memory newOrder =\n            ExecOrder({\n                user: _order.user,\n                inToken: _order.inToken,\n                outToken: _order.outToken,\n                amountPerTrade: _order.amountPerTrade,\n                nTradesLeft: _newNumTradesLeft, // the only updateable field for now\n                minSlippage: _order.minSlippage,\n                maxSlippage: _order.maxSlippage,\n                delay: _order.delay,\n                lastExecutionTime: _order.lastExecutionTime,\n                platformWallet: _order.platformWallet,\n                platformFeeBps: _order.platformFeeBps\n            });\n        _updateTask(abi.encode(_order), abi.encode(newOrder), _id, msg.sender);\n        if (_order.inToken == ETH) {\n            if (_order.nTradesLeft > _newNumTradesLeft) {\n                uint256 refundAmount =\n                    _order.amountPerTrade *\n                        (_order.nTradesLeft - _newNumTradesLeft);\n\n                (bool success, ) = _order.user.call{value: refundAmount}(\"\");\n                require(\n                    success,\n                    \"GelatoKrystal.editNumTrades: revert on transfer\"\n                );\n            } else {\n                uint256 topUpAmount =\n                    _order.amountPerTrade *\n                        (_newNumTradesLeft - _order.nTradesLeft);\n\n                require(\n                    topUpAmount == msg.value,\n                    \"GelatoKrystal.editNumTrades: mismatching amount of ETH deposited\"\n                );\n            }\n        }\n\n        emit LogTaskUpdated(_id, newOrder);\n    }\n\n    // solhint-disable-next-line function-max-lines\n    function exec(\n        ExecOrder calldata _order,\n        uint256 _id,\n        Dex _protocol,\n        Fee memory _fee,\n        address[] calldata _tradePath\n    )\n        external\n        gelatofy(\n            _fee.isOutToken ? _order.outToken : _order.inToken,\n            _order.user,\n            abi.encode(_order),\n            _id,\n            _fee.amount,\n            _fee.swapRate\n        )\n    {\n        // task cycle logic\n        if (_order.nTradesLeft > 1) {\n            _updateAndSubmitNextTask(_order, _id);\n        } else {\n            _removeTask(abi.encode(_order), _id, _order.user);\n        }\n\n        // action exec\n        uint256 amountOut;\n        if (_protocol == Dex.KYBER) {\n            amountOut = _actionKyber(_order, _fee.amount, _fee.isOutToken);\n        } else {\n            amountOut = _actionUniOrSushi(\n                _order,\n                _protocol,\n                _tradePath,\n                _fee.amount,\n                _fee.isOutToken\n            );\n        }\n\n        if (_fee.isOutToken) {\n            _transferEthOrToken(\n                payable(_order.user),\n                _order.outToken,\n                amountOut\n            );\n        }\n\n        emit LogKrystalTrade(_id, _order, amountOut);\n    }\n\n    function isTaskSubmitted(ExecOrder calldata _order, uint256 _id)\n        external\n        view\n        returns (bool)\n    {\n        return verifyTask(abi.encode(_order), _id, _order.user);\n    }\n\n    function getMinReturn(ExecOrder memory _order)\n        public\n        view\n        returns (uint256 minReturn)\n    {\n        // Rate Check\n        (uint256 idealReturn, ) =\n            IOracleAggregator(IGelato(gelato).getOracleAggregator())\n                .getExpectedReturnAmount(\n                _order.amountPerTrade,\n                _order.inToken,\n                _order.outToken\n            );\n\n        require(\n            idealReturn > 0,\n            \"GelatoKrystal.getMinReturn: idealReturn cannot be 0\"\n        );\n\n        // check time (reverts if block.timestamp is below execTime)\n        uint256 timeSinceCanExec =\n            // solhint-disable-next-line not-rely-on-time\n            block.timestamp - (_order.lastExecutionTime + _order.delay);\n\n        uint256 minSlippageFactor = TOTAL_BPS - _order.minSlippage;\n        uint256 maxSlippageFactor = TOTAL_BPS - _order.maxSlippage;\n        uint256 slippage;\n        if (minSlippageFactor > timeSinceCanExec) {\n            slippage = minSlippageFactor - timeSinceCanExec;\n        }\n\n        if (maxSlippageFactor > slippage) {\n            slippage = maxSlippageFactor;\n        }\n\n        minReturn = (idealReturn * slippage) / TOTAL_BPS;\n    }\n\n    function isSwapPossible(address _inToken, address _outToken)\n        external\n        view\n        returns (bool isPossible)\n    {\n        (uint256 idealReturn, ) =\n            IOracleAggregator(IGelato(gelato).getOracleAggregator())\n                .getExpectedReturnAmount(1e18, _inToken, _outToken);\n        isPossible = idealReturn == 0 ? false : true;\n    }\n\n    // ############# PRIVATE #############\n    function _actionKyber(\n        ExecOrder memory _order,\n        uint256 _fee,\n        bool _outTokenFee\n    ) private returns (uint256 received) {\n        (\n            uint256 ethToSend,\n            uint256 sellAmount,\n            uint256 minReturn,\n            address payable receiver\n        ) = _preExec(_order, _fee, _outTokenFee);\n\n        received = _doKyberTrade(\n            _order.inToken,\n            _order.outToken,\n            sellAmount,\n            _getKyberRate(\n                sellAmount,\n                minReturn,\n                _order.inToken,\n                _order.outToken\n            ),\n            receiver,\n            ethToSend,\n            _order.platformWallet,\n            _order.platformFeeBps\n        );\n\n        if (_outTokenFee) {\n            received = received - _fee;\n        }\n    }\n\n    function _doKyberTrade(\n        address inToken,\n        address outToken,\n        uint256 sellAmount,\n        uint256 minRate,\n        address payable receiver,\n        uint256 ethToSend,\n        address _platformWallet,\n        uint256 _platformFeeBps\n    ) private returns (uint256 received) {\n        received = smartWalletSwap.swapKyber{value: ethToSend}(\n            IERC20(inToken),\n            IERC20(outToken),\n            sellAmount,\n            minRate,\n            receiver,\n            _platformFeeBps,\n            payable(_platformWallet),\n            HINT,\n            false\n        );\n    }\n\n    function _actionUniOrSushi(\n        ExecOrder memory _order,\n        Dex _protocol,\n        address[] memory _tradePath,\n        uint256 _fee,\n        bool _outTokenFee\n    ) private returns (uint256 received) {\n        (\n            uint256 ethToSend,\n            uint256 sellAmount,\n            uint256 minReturn,\n            address payable receiver\n        ) = _preExec(_order, _fee, _outTokenFee);\n\n        require(\n            _order.inToken == _tradePath[0] &&\n                _order.outToken == _tradePath[_tradePath.length - 1],\n            \"GelatoDCA.action: trade path does not match order.\"\n        );\n\n        received = _doUniTrade(\n            _order,\n            _protocol,\n            _tradePath,\n            sellAmount,\n            minReturn,\n            receiver,\n            ethToSend\n        );\n\n        if (_outTokenFee) {\n            received = received - _fee;\n        }\n    }\n\n    function _doUniTrade(\n        ExecOrder memory _order,\n        Dex _protocol,\n        address[] memory _tradePath,\n        uint256 sellAmount,\n        uint256 minReturn,\n        address payable receiver,\n        uint256 ethToSend\n    ) private returns (uint256 received) {\n        received = _doUniTrade(\n            _protocol == Dex.UNISWAP ? uniRouterV2 : sushiRouterV2,\n            _tradePath,\n            sellAmount,\n            minReturn,\n            receiver,\n            ethToSend,\n            _order.platformWallet,\n            _order.platformFeeBps\n        );\n    }\n\n    function _doUniTrade(\n        IUniswapV2Router02 router,\n        address[] memory tradePath,\n        uint256 sellAmount,\n        uint256 minReturn,\n        address payable receiver,\n        uint256 ethToSend,\n        address _platformWallet,\n        uint256 _platformFeeBps\n    ) private returns (uint256 received) {\n        received = smartWalletSwap.swapUniswap{value: ethToSend}(\n            router,\n            sellAmount,\n            minReturn,\n            tradePath,\n            receiver,\n            _platformFeeBps,\n            payable(_platformWallet),\n            false,\n            false\n        );\n    }\n\n    function _preExec(\n        ExecOrder memory _order,\n        uint256 _fee,\n        bool _outTokenFee\n    )\n        private\n        returns (\n            uint256 ethToSend,\n            uint256 sellAmount,\n            uint256 minReturn,\n            address payable receiver\n        )\n    {\n        if (_outTokenFee) {\n            receiver = payable(this);\n            minReturn = getMinReturn(_order) + _fee;\n            sellAmount = _order.amountPerTrade;\n        } else {\n            receiver = payable(_order.user);\n            minReturn = getMinReturn(_order);\n            sellAmount = _order.amountPerTrade - _fee;\n        }\n\n        if (_order.inToken != ETH) {\n            IERC20(_order.inToken).safeTransferFrom(\n                _order.user,\n                address(this),\n                _order.amountPerTrade\n            );\n            IERC20(_order.inToken).safeIncreaseAllowance(\n                address(smartWalletSwap),\n                sellAmount\n            );\n        } else {\n            ethToSend = sellAmount;\n        }\n    }\n\n    function _updateAndSubmitNextTask(ExecOrder memory _order, uint256 _id)\n        private\n    {\n        bytes memory lastOrder = abi.encode(_order);\n        // update next order\n        _order.nTradesLeft = _order.nTradesLeft - 1;\n        // solhint-disable-next-line not-rely-on-time\n        _order.lastExecutionTime = block.timestamp;\n\n        _updateTask(lastOrder, abi.encode(_order), _id, _order.user);\n        emit LogTaskSubmitted(_id, _order);\n    }\n\n    function _storeOrder(ExecOrder memory _order) private {\n        uint256 id = _storeTask(abi.encode(_order), _order.user);\n        emit LogTaskSubmitted(id, _order);\n    }\n\n    function _getKyberRate(\n        uint256 _amountIn,\n        uint256 _minReturn,\n        address _inToken,\n        address _outToken\n    ) private view returns (uint256) {\n        uint256 newAmountIn =\n            _to18Decimals(\n                _inToken,\n                _amountIn,\n                \"GelatoKrystal:_getKyberRate: newAmountIn revert\"\n            );\n        uint256 newMinReturn =\n            _to18Decimals(\n                _outToken,\n                _minReturn,\n                \"GelatoKrystal:_getKyberRate: newMinReturn revert\"\n            );\n        return wdiv(newMinReturn, newAmountIn);\n    }\n}\n"
    },
    "contracts/interfaces/krystal/ISmartWalletSwapImplementation.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport \"./ISmartWalletLending.sol\";\nimport {\n    IERC20\n} from \"../../vendor/openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {IUniswapV2Router02} from \"../uniswap/IUniswapV2Router02.sol\";\n\ninterface ISmartWalletSwapImplementation {\n    event KyberTrade(\n        address indexed trader,\n        IERC20 indexed src,\n        IERC20 indexed dest,\n        uint256 srcAmount,\n        uint256 destAmount,\n        address recipient,\n        uint256 platformFeeBps,\n        address platformWallet,\n        bytes hint,\n        bool useGasToken,\n        uint256 numGasBurns\n    );\n\n    event UniswapTrade(\n        address indexed trader,\n        address indexed router,\n        address[] tradePath,\n        uint256 srcAmount,\n        uint256 destAmount,\n        address recipient,\n        uint256 platformFeeBps,\n        address platformWallet,\n        bool feeInSrc,\n        bool useGasToken,\n        uint256 numGasBurns\n    );\n\n    event KyberTradeAndDeposit(\n        address indexed trader,\n        ISmartWalletLending.LendingPlatform indexed platform,\n        IERC20 src,\n        IERC20 indexed dest,\n        uint256 srcAmount,\n        uint256 destAmount,\n        uint256 platformFeeBps,\n        address platformWallet,\n        bytes hint,\n        bool useGasToken,\n        uint256 numGasBurns\n    );\n\n    event UniswapTradeAndDeposit(\n        address indexed trader,\n        ISmartWalletLending.LendingPlatform indexed platform,\n        IUniswapV2Router02 indexed router,\n        address[] tradePath,\n        uint256 srcAmount,\n        uint256 destAmount,\n        uint256 platformFeeBps,\n        address platformWallet,\n        bool useGasToken,\n        uint256 numGasBurns\n    );\n\n    event BorrowFromLending(\n        ISmartWalletLending.LendingPlatform indexed platform,\n        IERC20 token,\n        uint256 amountBorrowed,\n        uint256 interestRateMode,\n        bool useGasToken,\n        uint256 numGasBurns\n    );\n\n    event WithdrawFromLending(\n        ISmartWalletLending.LendingPlatform indexed platform,\n        IERC20 token,\n        uint256 amount,\n        uint256 minReturn,\n        uint256 actualReturnAmount,\n        bool useGasToken,\n        uint256 numGasBurns\n    );\n\n    event KyberTradeAndRepay(\n        address indexed trader,\n        ISmartWalletLending.LendingPlatform indexed platform,\n        IERC20 src,\n        IERC20 indexed dest,\n        uint256 srcAmount,\n        uint256 destAmount,\n        uint256 payAmount,\n        uint256 feeAndRateMode,\n        address platformWallet,\n        bytes hint,\n        bool useGasToken,\n        uint256 numGasBurns\n    );\n\n    event UniswapTradeAndRepay(\n        address indexed trader,\n        ISmartWalletLending.LendingPlatform indexed platform,\n        IUniswapV2Router02 indexed router,\n        address[] tradePath,\n        uint256 srcAmount,\n        uint256 destAmount,\n        uint256 payAmount,\n        uint256 feeAndRateMode,\n        address platformWallet,\n        bool useGasToken,\n        uint256 numGasBurns\n    );\n\n    function getExpectedReturnKyber(\n        IERC20 src,\n        IERC20 dest,\n        uint256 srcAmount,\n        uint256 platformFeeBps,\n        bytes calldata hint\n    ) external view returns (uint256 destAmount, uint256 expectedRate);\n\n    function getExpectedReturnUniswap(\n        IUniswapV2Router02 router,\n        uint256 srcAmount,\n        address[] calldata tradePath,\n        uint256 platformFeeBps\n    ) external view returns (uint256 destAmount, uint256 expectedRate);\n\n    function swapKyber(\n        IERC20 src,\n        IERC20 dest,\n        uint256 srcAmount,\n        uint256 minConversionRate,\n        address payable recipient,\n        uint256 platformFeeBps,\n        address payable platformWallet,\n        bytes calldata hint,\n        bool useGasToken\n    ) external payable returns (uint256 destAmount);\n\n    function swapUniswap(\n        IUniswapV2Router02 router,\n        uint256 srcAmount,\n        uint256 minDestAmount,\n        address[] calldata tradePath,\n        address payable recipient,\n        uint256 platformFeeBps,\n        address payable platformWallet,\n        bool feeInSrc,\n        bool useGasToken\n    ) external payable returns (uint256 destAmount);\n\n    function swapKyberAndDeposit(\n        ISmartWalletLending.LendingPlatform platform,\n        IERC20 src,\n        IERC20 dest,\n        uint256 srcAmount,\n        uint256 minConversionRate,\n        uint256 platformFeeBps,\n        address payable platformWallet,\n        bytes calldata hint,\n        bool useGasToken\n    ) external payable returns (uint256 destAmount);\n\n    function swapUniswapAndDeposit(\n        ISmartWalletLending.LendingPlatform platform,\n        IUniswapV2Router02 router,\n        uint256 srcAmount,\n        uint256 minDestAmount,\n        address[] calldata tradePath,\n        uint256 platformFeeBps,\n        address payable platformWallet,\n        bool useGasToken\n    ) external payable returns (uint256 destAmount);\n\n    function withdrawFromLendingPlatform(\n        ISmartWalletLending.LendingPlatform platform,\n        IERC20 token,\n        uint256 amount,\n        uint256 minReturn,\n        bool useGasToken\n    ) external returns (uint256 returnedAmount);\n\n    function swapKyberAndRepay(\n        ISmartWalletLending.LendingPlatform platform,\n        IERC20 src,\n        IERC20 dest,\n        uint256 srcAmount,\n        uint256 payAmount,\n        uint256 feeAndRateMode,\n        address payable platformWallet,\n        bytes calldata hint,\n        bool useGasToken\n    ) external payable returns (uint256 destAmount);\n\n    function swapUniswapAndRepay(\n        ISmartWalletLending.LendingPlatform platform,\n        IUniswapV2Router02 router,\n        uint256 srcAmount,\n        uint256 payAmount,\n        address[] calldata tradePath,\n        uint256 feeAndRateMode,\n        address payable platformWallet,\n        bool useGasToken\n    ) external payable returns (uint256 destAmount);\n\n    function claimComp(\n        address[] calldata holders,\n        ICompErc20[] calldata cTokens,\n        bool borrowers,\n        bool suppliers,\n        bool useGasToken\n    ) external;\n\n    function claimPlatformFees(\n        address[] calldata platformWallets,\n        IERC20[] calldata tokens\n    ) external;\n}\n"
    },
    "contracts/vendor/DSMath.sol": {
      "content": "// \"SPDX-License-Identifier: AGPL-3.0-or-later\"\n/// math.sol -- mixin for inline numerical wizardry\n\n// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\npragma solidity 0.8.0;\n\nfunction add(uint256 x, uint256 y) pure returns (uint256 z) {\n    require((z = x + y) >= x, \"ds-math-add-overflow\");\n}\n\nfunction sub(uint256 x, uint256 y) pure returns (uint256 z) {\n    require((z = x - y) <= x, \"ds-math-sub-underflow\");\n}\n\nfunction mul(uint256 x, uint256 y) pure returns (uint256 z) {\n    require(y == 0 || (z = x * y) / y == x, \"ds-math-mul-overflow\");\n}\n\nfunction div(uint256 x, uint256 y) pure returns (uint256 z) {\n    // Solidity only automatically asserts when dividing by 0\n    require(y > 0, \"ds-math-division-by-zero\");\n    z = x / y;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n}\n\nfunction min(uint256 x, uint256 y) pure returns (uint256 z) {\n    return x <= y ? x : y;\n}\n\nfunction max(uint256 x, uint256 y) pure returns (uint256 z) {\n    return x >= y ? x : y;\n}\n\nfunction imin(int256 x, int256 y) pure returns (int256 z) {\n    return x <= y ? x : y;\n}\n\nfunction imax(int256 x, int256 y) pure returns (int256 z) {\n    return x >= y ? x : y;\n}\n\nuint256 constant WAD = 10**18;\nuint256 constant RAY = 10**27;\n\n//rounds to zero if x*y < WAD / 2\nfunction wmul(uint256 x, uint256 y) pure returns (uint256 z) {\n    z = add(mul(x, y), WAD / 2) / WAD;\n}\n\n//rounds to zero if x*y < WAD / 2\nfunction rmul(uint256 x, uint256 y) pure returns (uint256 z) {\n    z = add(mul(x, y), RAY / 2) / RAY;\n}\n\n//rounds to zero if x*y < WAD / 2\nfunction wdiv(uint256 x, uint256 y) pure returns (uint256 z) {\n    z = add(mul(x, WAD), y / 2) / y;\n}\n\n//rounds to zero if x*y < RAY / 2\nfunction rdiv(uint256 x, uint256 y) pure returns (uint256 z) {\n    z = add(mul(x, RAY), y / 2) / y;\n}\n\n// This famous algorithm is called \"exponentiation by squaring\"\n// and calculates x^n with x as fixed-point and n as regular unsigned.\n//\n// It's O(log n), instead of O(n) for naive repeated multiplication.\n//\n// These facts are why it works:\n//\n//  If n is even, then x^n = (x^2)^(n/2).\n//  If n is odd,  then x^n = x * x^(n-1),\n//   and applying the equation for even x gives\n//    x^n = x * (x^2)^((n-1) / 2).\n//\n//  Also, EVM division is flooring and\n//    floor[(n-1) / 2] = floor[n / 2].\n//\nfunction rpow(uint256 x, uint256 n) pure returns (uint256 z) {\n    z = n % 2 != 0 ? x : RAY;\n\n    for (n /= 2; n != 0; n /= 2) {\n        x = rmul(x, x);\n\n        if (n % 2 != 0) {\n            z = rmul(z, x);\n        }\n    }\n}\n"
    },
    "contracts/vendor/kyber/utils/IKyberProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    IERC20\n} from \"../../openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IKyberProxy {\n    function tradeWithHintAndFee(\n        IERC20 src,\n        uint256 srcAmount,\n        IERC20 dest,\n        address payable destAddress,\n        uint256 maxDestAmount,\n        uint256 minConversionRate,\n        address payable platformWallet,\n        uint256 platformFeeBps,\n        bytes calldata hint\n    ) external payable returns (uint256 destAmount);\n\n    function getExpectedRateAfterFee(\n        IERC20 src,\n        IERC20 dest,\n        uint256 srcQty,\n        uint256 platformFeeBps,\n        bytes calldata hint\n    ) external view returns (uint256 expectedRate);\n}"
    },
    "contracts/interfaces/chainlink/IChainlinkOracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IChainlinkOracle {\n    function latestAnswer() external view returns (int256);\n\n    function decimals() external view returns (uint256);\n}\n\ninterface AggregatorV3Interface {\n    function decimals() external view returns (uint8);\n\n    function description() external view returns (string memory);\n\n    function version() external view returns (uint256);\n\n    // getRoundData and latestRoundData should both raise \"No data present\"\n    // if they do not have data to report, instead of returning unset values\n    // which could be misinterpreted as actual reported values.\n    function getRoundData(uint80 _roundId)\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n\n    function latestRoundData()\n        external\n        view\n        returns (\n            uint80 roundId,\n            int256 answer,\n            uint256 startedAt,\n            uint256 updatedAt,\n            uint80 answeredInRound\n        );\n}\n"
    },
    "contracts/interfaces/gelato/IOracleAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\n/**\n * @dev Interface of the Oracle Aggregator Contract\n */\ninterface IOracleAggregator {\n    function getExpectedReturnAmount(\n        uint256 amount,\n        address tokenAddressA,\n        address tokenAddressB\n    ) external view returns (uint256 returnAmount, uint256 decimals);\n}"
    },
    "contracts/interfaces/gelato/ITaskStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface ITaskStorage {\n    function storeTask(bytes calldata _bytesBlob) external returns (uint256);\n\n    function removeTask(bytes32 _taskHash) external;\n\n    function taskId() external view returns (uint256);\n\n    function taskOwner(bytes32 _taskHash) external view returns (address);\n}"
    },
    "contracts/interfaces/uniswap/IUniswapV2Router02.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity 0.8.0;\n\ninterface IUniswapV2Router02 {\n    function swapExactTokensForTokens(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint256 amountOut,\n        uint256 amountInMax,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint256 amountIn,\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external returns (uint256[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint256 amountOutMin,\n        address[] calldata path,\n        address to,\n        uint256 deadline\n    ) external payable returns (uint256[] memory amounts);\n\n    function getAmountsOut(uint256 amountIn, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function getAmountsIn(uint256 amountOut, address[] calldata path)\n        external\n        view\n        returns (uint256[] memory amounts);\n\n    function factory() external pure returns (address);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function WETH() external pure returns (address);\n}\n"
    },
    "contracts/gelato/functions/FToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    SafeERC20\n} from \"../../vendor/openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {\n    IERC20\n} from \"../../vendor/openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ETH} from \"../constants/CTokens.sol\";\n\nfunction _to18Decimals(\n    address _token,\n    uint256 _amount,\n    string memory _revertMsg\n) view returns (uint256) {\n    if (_token == ETH) return _amount;\n\n    try IERC20(_token).decimals() returns (uint8 _decimals) {\n        return (_amount * (10**18)) / (10**uint256(_decimals));\n    } catch {\n        revert(_revertMsg);\n    }\n}"
    },
    "contracts/gelato/standards/SimpleServiceStandard.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {TaskStorage} from \"./TaskStorage.sol\";\nimport {\n    _transferEthOrToken,\n    _swapTokenToEthTransfer\n} from \"../functions/FPayment.sol\";\nimport {_getExpectedReturnAmount} from \"../functions/FGelato.sol\";\nimport {ETH} from \"../constants/CTokens.sol\";\n\nabstract contract SimpleServiceStandard is TaskStorage {\n    address public immutable gelato;\n\n    event LogExecSuccess(\n        uint256 indexed taskId,\n        address indexed executor,\n        uint256 postExecFee,\n        uint256 rate,\n        address creditToken\n    );\n\n    modifier gelatofy(\n        address _creditToken,\n        address _user,\n        bytes memory _bytes,\n        uint256 _id,\n        uint256 _fee,\n        uint256 _swapRate\n    ) {\n        // Check only Gelato is calling\n        require(\n            address(gelato) == msg.sender,\n            \"SimpleServiceStandard: Caller is not gelato\"\n        );\n\n        // Verify tasks actually exists\n        require(\n            verifyTask(_bytes, _id, _user),\n            \"SimpleServiceStandard: invalid task\"\n        );\n\n        // _removeTask(_bytes, _id, _user);\n\n        // Execute Logic\n        _;\n\n        // Pay Gelato\n        if (_swapRate == 0)\n            _transferEthOrToken(payable(gelato), _creditToken, _fee);\n        else if (\n            _getExpectedReturnAmount(_creditToken, ETH, _fee, gelato) == 0\n        ) {\n            _swapTokenToEthTransfer(gelato, _creditToken, _fee, _swapRate);\n        }\n\n        emit LogExecSuccess(_id, tx.origin, _fee, _swapRate, _creditToken);\n    }\n\n    constructor(address _gelato) {\n        gelato = _gelato;\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    function verifyTask(\n        bytes memory _bytes,\n        uint256 _id,\n        address _user\n    ) public view returns (bool) {\n        // Check whether owner is valid\n        return taskOwner[hashTask(_bytes, _id)] == _user;\n    }\n}\n"
    },
    "contracts/gelato/functions/FPayment.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {ETH, WETH} from \"../constants/CTokens.sol\";\nimport {UNISWAPV2_ROUTER02} from \"../constants/CUniswap.sol\";\nimport {\n    IUniswapV2Router02\n} from \"../../interfaces/uniswap/IUniswapV2Router02.sol\";\nimport {\n    SafeERC20\n} from \"../../vendor/openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {\n    IERC20\n} from \"../../vendor/openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nfunction _transferEthOrToken(\n    address payable _to,\n    address _paymentToken,\n    uint256 _amt\n) {\n    if (_paymentToken == ETH) {\n        (bool success, ) = _to.call{value: _amt}(\"\");\n        require(success, \"_transfer: fail\");\n    } else {\n        SafeERC20.safeTransfer(IERC20(_paymentToken), _to, _amt);\n    }\n}\n\nfunction _swapTokenToEthTransfer(\n    address _gelato,\n    address _creditToken,\n    uint256 _feeAmount,\n    uint256 _swapRate\n) {\n    address[] memory path = new address[](2);\n    path[0] = _creditToken;\n    path[1] = WETH;\n    SafeERC20.safeIncreaseAllowance(\n        IERC20(_creditToken),\n        UNISWAPV2_ROUTER02,\n        _feeAmount\n    );\n    IUniswapV2Router02(UNISWAPV2_ROUTER02).swapExactTokensForETH(\n        _feeAmount, // amountIn\n        _swapRate, // amountOutMin\n        path, // path\n        _gelato, // receiver\n        // solhint-disable-next-line not-rely-on-time\n        block.timestamp // deadline\n    );\n}\n\nfunction _getBalance(address _token, address _account)\n    view\n    returns (uint256 balance)\n{\n    return\n        _token == ETH ? _account.balance : IERC20(_token).balanceOf(_account);\n}"
    },
    "contracts/gelato/constants/CTokens.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nuint256 constant DECIMALS_USD = 8;\n\nuint256 constant DECIMALS_USDT = 6;\n\nuint256 constant DECIMALS_USDC = 6;\n\nuint256 constant DECIMALS_DAI = 18;\n\nuint256 constant DECIMALS_BUSD = 18;\n\nuint256 constant DECIMALS_SUSD = 18;\n\nuint256 constant DECIMALS_TUSD = 18;\n\naddress constant USD = 0x7354C81fbCb229187480c4f497F945C6A312d5C3; // Random address\n\naddress constant ETH = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\n\naddress constant WETH = 0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;\n\naddress constant USDT = 0xdAC17F958D2ee523a2206206994597C13D831ec7;\n\naddress constant USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;\n\naddress constant DAI = 0x6B175474E89094C44Da98b954EedeAC495271d0F;\n\naddress constant BUSD = 0x4Fabb145d64652a948d72533023f6E7A623C7C53;\n\naddress constant SUSD = 0x57Ab1ec28D129707052df4dF418D58a2D46d5f51;\n\naddress constant TUSD = 0x0000000000085d4780B73119b644AE5ecd22b376;\n\naddress constant AAVE = 0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9;\n\naddress constant ADX = 0xADE00C28244d5CE17D72E40330B1c318cD12B7c3;\n\naddress constant BAT = 0x0D8775F648430679A709E98d2b0Cb6250d2887EF;\n\naddress constant BNB = 0xB8c77482e45F1F44dE1745F52C74426C631bDD52;\n\naddress constant BNT = 0x1F573D6Fb3F13d689FF844B4cE37794d79a7FF1C;\n\naddress constant BZRX = 0x56d811088235F11C8920698a204A5010a788f4b3;\n\naddress constant COMP = 0xc00e94Cb662C3520282E6f5717214004A7f26888;\n\naddress constant CRO = 0xA0b73E1Ff0B80914AB6fe0444E65848C4C34450b;\n\naddress constant DMG = 0xEd91879919B71bB6905f23af0A68d231EcF87b14;\n\naddress constant ENJ = 0xF629cBd94d3791C9250152BD8dfBDF380E2a3B9c;\n\naddress constant KNC = 0xdd974D5C2e2928deA5F71b9825b8b646686BD200;\n\naddress constant LINK = 0x514910771AF9Ca656af840dff83E8264EcF986CA;\n\naddress constant LRC = 0xBBbbCA6A901c926F240b89EacB641d8Aec7AEafD;\n\naddress constant MANA = 0x0F5D2fB29fb7d3CFeE444a200298f468908cC942;\n\naddress constant MKR = 0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2;\n\naddress constant NMR = 0x1776e1F26f98b1A5dF9cD347953a26dd3Cb46671;\n\naddress constant REN = 0x408e41876cCCDC0F92210600ef50372656052a38;\n\naddress constant REP = 0x221657776846890989a759BA2973e427DfF5C9bB;\n\naddress constant SNX = 0xC011a73ee8576Fb46F5E1c5751cA3B9Fe0af2a6F;\n\naddress constant SXP = 0x8CE9137d39326AD0cD6491fb5CC0CbA0e089b6A9;\n\naddress constant UNI = 0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984;\n\naddress constant WOM = 0xa982B2e19e90b2D9F7948e9C1b65D119F1CE88D6;\n\naddress constant YFI = 0x0bc529c00C6401aEF6D220BE8C6Ea1667F6Ad93e;\n\naddress constant ZRX = 0xE41d2489571d322189246DaFA5ebDe1F4699F498;\n"
    },
    "contracts/gelato/structs/SGelato.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nstruct Fee {\n    uint256 amount;\n    uint256 swapRate;\n    bool isOutToken;\n}"
    },
    "contracts/interfaces/gelato/IGelato.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\nimport {IDiamondCut} from \"../diamond/IDiamondCut.sol\";\nimport {IDiamondLoupe} from \"../diamond/IDiamondLoupe.sol\";\nimport {\n    TaskReceipt\n} from \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\";\nimport {IGelatoV1} from \"./IGelatoV1.sol\";\n\n// solhint-disable ordering\n\n/// @dev includes the interfaces of all facets\ninterface IGelato {\n    // ########## Diamond Cut Facet #########\n    event DiamondCut(\n        IDiamondCut.FacetCut[] _diamondCut,\n        address _init,\n        bytes _calldata\n    );\n\n    function diamondCut(\n        IDiamondCut.FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n\n    // ########## DiamondLoupeFacet #########\n    function facets()\n        external\n        view\n        returns (IDiamondLoupe.Facet[] memory facets_);\n\n    function facetFunctionSelectors(address _facet)\n        external\n        view\n        returns (bytes4[] memory facetFunctionSelectors_);\n\n    function facetAddresses()\n        external\n        view\n        returns (address[] memory facetAddresses_);\n\n    function facetAddress(bytes4 _functionSelector)\n        external\n        view\n        returns (address facetAddress_);\n\n    function supportsInterface(bytes4 _interfaceId)\n        external\n        view\n        returns (bool);\n\n    // ########## Ownership Facet #########\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    function transferOwnership(address _newOwner) external;\n\n    function owner() external view returns (address owner_);\n\n    // ########## AddressFacet #########\n    event LogSetOracleAggregator(address indexed oracleAggregator);\n    event LogSetGasPriceOracle(address indexed gasPriceOracle);\n\n    function setOracleAggregator(address _oracleAggregator)\n        external\n        returns (address);\n\n    function setGasPriceOracle(address _gasPriceOracle)\n        external\n        returns (address);\n\n    function getOracleAggregator() external view returns (address);\n\n    function getGasPriceOracle() external view returns (address);\n\n    // ########## ConcurrentCanExecFacet #########\n    enum SlotStatus {Open, Closing, Closed}\n\n    function setSlotLength(uint256 _slotLength) external;\n\n    function slotLength() external view returns (uint256);\n\n    function concurrentCanExec(uint256 _buffer) external view returns (bool);\n\n    function getCurrentExecutorIndex()\n        external\n        view\n        returns (uint256 executorIndex, uint256 remainingBlocksInSlot);\n\n    function currentExecutor()\n        external\n        view\n        returns (\n            address executor,\n            uint256 executorIndex,\n            uint256 remainingBlocksInSlot\n        );\n\n    function mySlotStatus(uint256 _buffer) external view returns (SlotStatus);\n\n    function calcExecutorIndex(\n        uint256 _currentBlock,\n        uint256 _blocksPerSlot,\n        uint256 _numberOfExecutors\n    )\n        external\n        pure\n        returns (uint256 executorIndex, uint256 remainingBlocksInSlot);\n\n    // ########## ExecFacet #########\n    event LogExecSuccess(\n        address indexed executor,\n        address indexed service,\n        bool indexed wasExecutorPaid\n    );\n\n    event LogSetGasMargin(uint256 oldGasMargin, uint256 newGasMargin);\n\n    function addExecutors(address[] calldata _executors) external;\n\n    function removeExecutors(address[] calldata _executors) external;\n\n    function setGasMargin(uint256 _gasMargin) external;\n\n    function exec(\n        address _service,\n        bytes calldata _data,\n        address _creditToken\n    ) external;\n\n    function estimateExecGasDebit(\n        address _service,\n        bytes calldata _data,\n        address _creditToken\n    ) external returns (uint256 gasDebitInETH, uint256 gasDebitInCreditToken);\n\n    function canExec(address _executor) external view returns (bool);\n\n    function isExecutor(address _executor) external view returns (bool);\n\n    function executors() external view returns (address[] memory);\n\n    function numberOfExecutors() external view returns (uint256);\n\n    function gasMargin() external view returns (uint256);\n\n    // ########## GelatoV1Facet #########\n    struct Response {\n        uint256 taskReceiptId;\n        uint256 taskGasLimit;\n        string response;\n    }\n\n    function stakeExecutor(IGelatoV1 _gelatoCore) external payable;\n\n    function unstakeExecutor(IGelatoV1 _gelatoCore, address payable _to)\n        external;\n\n    function multiReassignProviders(\n        IGelatoV1 _gelatoCore,\n        address[] calldata _providers,\n        address _newExecutor\n    ) external;\n\n    function providerRefund(\n        IGelatoV1 _gelatoCore,\n        address _provider,\n        uint256 _amount\n    ) external;\n\n    function withdrawExcessExecutorStake(\n        IGelatoV1 _gelatoCore,\n        uint256 _withdrawAmount,\n        address payable _to\n    ) external;\n\n    function v1ConcurrentMultiCanExec(\n        address _gelatoCore,\n        TaskReceipt[] calldata _taskReceipts,\n        uint256 _gelatoGasPrice,\n        uint256 _buffer\n    )\n        external\n        view\n        returns (\n            bool canExecRes,\n            uint256 blockNumber,\n            Response[] memory responses\n        );\n\n    function v1MultiCanExec(\n        address _gelatoCore,\n        TaskReceipt[] calldata _taskReceipts,\n        uint256 _gelatoGasPrice\n    ) external view returns (uint256 blockNumber, Response[] memory responses);\n\n    function getGasLimit(\n        TaskReceipt calldata _taskReceipt,\n        uint256 _gelatoMaxGas\n    ) external pure returns (uint256);\n}"
    },
    "contracts/gelato/standards/TaskStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nabstract contract TaskStorage {\n    uint256 public taskId;\n    mapping(bytes32 => address) public taskOwner;\n\n    event LogTaskStored(\n        uint256 indexed id,\n        address indexed user,\n        bytes32 indexed taskHash,\n        bytes payload\n    );\n    event LogTaskRemoved(address indexed remover, bytes32 indexed taskHash);\n\n    function hashTask(bytes memory _blob, uint256 _taskId)\n        public\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encode(_blob, _taskId));\n    }\n\n    function _storeTask(bytes memory _blob, address _owner)\n        internal\n        returns (uint256 newTaskId)\n    {\n        newTaskId = ++taskId;\n\n        bytes32 taskHash = hashTask(_blob, taskId);\n        taskOwner[taskHash] = _owner;\n\n        emit LogTaskStored(taskId, _owner, taskHash, _blob);\n    }\n\n    function _removeTask(\n        bytes memory _blob,\n        uint256 _taskId,\n        address _owner\n    ) internal {\n        // Only address which created task can delete it\n        bytes32 taskHash = hashTask(_blob, _taskId);\n        require(\n            _owner == taskOwner[taskHash],\n            \"Task Storage: Only Owner can remove tasks\"\n        );\n\n        // delete task\n        delete taskOwner[taskHash];\n        emit LogTaskRemoved(msg.sender, taskHash);\n    }\n\n    function _updateTask(\n        bytes memory _bytesBlob,\n        bytes memory _newBytesBlob,\n        uint256 _taskId,\n        address _owner\n    ) internal {\n        _removeTask(_bytesBlob, _taskId, _owner);\n        bytes32 taskHash = hashTask(_newBytesBlob, _taskId);\n        taskOwner[taskHash] = _owner;\n\n        emit LogTaskStored(_taskId, _owner, taskHash, _bytesBlob);\n    }\n}\n"
    },
    "contracts/gelato/functions/FGelato.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {GELATO_GAS_PRICE_ORACLE} from \"../constants/CGelato.sol\";\nimport {\n    IChainlinkOracle\n} from \"../../interfaces/chainlink/IChainlinkOracle.sol\";\nimport {ETH} from \"../constants/CTokens.sol\";\nimport {mul, wmul} from \"../../vendor/DSMath.sol\";\nimport {IOracleAggregator} from \"../../interfaces/gelato/IOracleAggregator.sol\";\nimport {ORACLE_AGGREGATOR} from \"../constants/COracle.sol\";\nimport {IGelato} from \"../../interfaces/gelato/IGelato.sol\";\n\nfunction _getGelatoGasPrice(address _gasPriceOracle) view returns (uint256) {\n    return uint256(IChainlinkOracle(_gasPriceOracle).latestAnswer());\n}\n\n// Gelato Oracle price aggregator\nfunction _getExpectedBuyAmountFromChainlink(\n    address _buyAddr,\n    address _sellAddr,\n    uint256 _sellAmt\n) view returns (uint256 buyAmt) {\n    (buyAmt, ) = IOracleAggregator(ORACLE_AGGREGATOR).getExpectedReturnAmount(\n        _sellAmt,\n        _sellAddr,\n        _buyAddr\n    );\n}\n\n// Gelato Oracle price aggregator\nfunction _getExpectedReturnAmount(\n    address _inToken,\n    address _outToken,\n    uint256 _amt,\n    address _gelato\n) view returns (uint256 buyAmt) {\n    (buyAmt, ) = IOracleAggregator(IGelato(_gelato).getOracleAggregator())\n        .getExpectedReturnAmount(_amt, _inToken, _outToken);\n}\n\nfunction _getGelatoFee(\n    uint256 _gasOverhead,\n    uint256 _gasStart,\n    address _payToken,\n    address _gelato\n) view returns (uint256 gelatoFee) {\n    gelatoFee =\n        (_gasStart - gasleft() + _gasOverhead) *\n        _getCappedGasPrice(IGelato(_gelato).getGasPriceOracle());\n\n    if (_payToken == ETH) return gelatoFee;\n\n    // returns purely the ethereum tx fee\n    (gelatoFee, ) = IOracleAggregator(IGelato(_gelato).getOracleAggregator())\n        .getExpectedReturnAmount(gelatoFee, ETH, _payToken);\n}\n\nfunction _getCappedGasPrice(address _gasPriceOracle) view returns (uint256) {\n    uint256 oracleGasPrice = _getGelatoGasPrice(_gasPriceOracle);\n\n    // Use tx.gasprice capped by 1.3x Chainlink Oracle\n    return\n        tx.gasprice <= ((oracleGasPrice * 130) / 100)\n            ? tx.gasprice\n            : ((oracleGasPrice * 130) / 100);\n}"
    },
    "contracts/gelato/constants/CUniswap.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\naddress constant UNISWAPV2_ROUTER02 = 0x7a250d5630B4cF539739dF2C5dAcb4c659F2488D;\n"
    },
    "contracts/gelato/constants/CGelato.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {IChainlinkOracle} from \"../../interfaces/chainlink/IChainlinkOracle.sol\";\n\nIChainlinkOracle constant GELATO_GAS_PRICE_ORACLE = IChainlinkOracle(\n    0x169E633A2D1E6c10dD91238Ba11c4A708dfEF37C\n);\n\nstring constant OK = \"OK\";"
    },
    "contracts/gelato/constants/COracle.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\naddress constant ORACLE_AGGREGATOR = 0x64f31D46C52bBDe223D863B11dAb9327aB1414E9;"
    },
    "contracts/interfaces/diamond/IDiamondCut.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\ninterface IDiamondCut {\n    enum FacetCutAction {Add, Replace, Remove}\n    // Add=0, Replace=1, Remove=2\n\n    struct FacetCut {\n        address facetAddress;\n        FacetCutAction action;\n        bytes4[] functionSelectors;\n    }\n\n    event DiamondCut(FacetCut[] _diamondCut, address _init, bytes _calldata);\n\n    /// @notice Add/replace/remove any number of functions and optionally execute\n    ///         a function with delegatecall\n    /// @param _diamondCut Contains the facet addresses and function selectors\n    /// @param _init The address of the contract or facet to execute _calldata\n    /// @param _calldata A function call, including function selector and arguments\n    ///                  _calldata is executed with delegatecall on _init\n    function diamondCut(\n        FacetCut[] calldata _diamondCut,\n        address _init,\n        bytes calldata _calldata\n    ) external;\n}"
    },
    "contracts/interfaces/diamond/IDiamondLoupe.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.0;\n\n/******************************************************************************\\\n* Author: Nick Mudge <nick@perfectabstractions.com> (https://twitter.com/mudgen)\n* EIP-2535 Diamond Standard: https://eips.ethereum.org/EIPS/eip-2535\n/******************************************************************************/\n\n// A loupe is a small magnifying glass used to look at diamonds.\n// These functions look at diamonds\ninterface IDiamondLoupe {\n    /// These functions are expected to be called frequently\n    /// by tools.\n\n    struct Facet {\n        address facetAddress;\n        bytes4[] functionSelectors;\n    }\n\n    /// @notice Gets all facet addresses and their four byte function selectors.\n    /// @return facets_ Facet\n    function facets() external view returns (Facet[] memory facets_);\n\n    /// @notice Gets all the function selectors supported by a specific facet.\n    /// @param _facet The facet address.\n    /// @return facetFunctionSelectors_\n    function facetFunctionSelectors(address _facet)\n        external\n        view\n        returns (bytes4[] memory facetFunctionSelectors_);\n\n    /// @notice Get all the facet addresses used by a diamond.\n    /// @return facetAddresses_\n    function facetAddresses()\n        external\n        view\n        returns (address[] memory facetAddresses_);\n\n    /// @notice Gets the facet that supports the given selector.\n    /// @dev If facet is not found return address(0).\n    /// @param _functionSelector The function selector.\n    /// @return facetAddress_ The facet address.\n    function facetAddress(bytes4 _functionSelector)\n        external\n        view\n        returns (address facetAddress_);\n}"
    },
    "@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity >=0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {IGelatoProviderModule} from \"../../gelato_provider_modules/IGelatoProviderModule.sol\";\nimport {IGelatoCondition} from \"../../gelato_conditions/IGelatoCondition.sol\";\n\nstruct Provider {\n    address addr;  //  if msg.sender == provider => self-Provider\n    IGelatoProviderModule module;  //  can be IGelatoProviderModule(0) for self-Providers\n}\n\nstruct Condition {\n    IGelatoCondition inst;  // can be AddressZero for self-conditional Actions\n    bytes data;  // can be bytes32(0) for self-conditional Actions\n}\n\nenum Operation { Call, Delegatecall }\n\nenum DataFlow { None, In, Out, InAndOut }\n\nstruct Action {\n    address addr;\n    bytes data;\n    Operation operation;\n    DataFlow dataFlow;\n    uint256 value;\n    bool termsOkCheck;\n}\n\nstruct Task {\n    Condition[] conditions;  // optional\n    Action[] actions;\n    uint256 selfProviderGasLimit;  // optional: 0 defaults to gelatoMaxGas\n    uint256 selfProviderGasPriceCeil;  // optional: 0 defaults to NO_CEIL\n}\n\nstruct TaskReceipt {\n    uint256 id;\n    address userProxy;\n    Provider provider;\n    uint256 index;\n    Task[] tasks;\n    uint256 expiryDate;\n    uint256 cycleId;  // auto-filled by GelatoCore. 0 for non-cyclic/chained tasks\n    uint256 submissionsLeft;\n}\n\ninterface IGelatoCore {\n    event LogTaskSubmitted(\n        uint256 indexed taskReceiptId,\n        bytes32 indexed taskReceiptHash,\n        TaskReceipt taskReceipt\n    );\n\n    event LogExecSuccess(\n        address indexed executor,\n        uint256 indexed taskReceiptId,\n        uint256 executorSuccessFee,\n        uint256 sysAdminSuccessFee\n    );\n    event LogCanExecFailed(\n        address indexed executor,\n        uint256 indexed taskReceiptId,\n        string reason\n    );\n    event LogExecReverted(\n        address indexed executor,\n        uint256 indexed taskReceiptId,\n        uint256 executorRefund,\n        string reason\n    );\n\n    event LogTaskCancelled(uint256 indexed taskReceiptId, address indexed cancellor);\n\n    /// @notice API to query whether Task can be submitted successfully.\n    /// @dev In submitTask the msg.sender must be the same as _userProxy here.\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _userProxy The userProxy from which the task will be submitted.\n    /// @param _task Selected provider, conditions, actions, expiry date of the task\n    function canSubmitTask(\n        address _userProxy,\n        Provider calldata _provider,\n        Task calldata _task,\n        uint256 _expiryDate\n    )\n        external\n        view\n        returns(string memory);\n\n    /// @notice API to submit a single Task.\n    /// @dev You can let users submit multiple tasks at once by batching calls to this.\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _task A Gelato Task object: provider, conditions, actions.\n    /// @param _expiryDate From then on the task cannot be executed. 0 for infinity.\n    function submitTask(\n        Provider calldata _provider,\n        Task calldata _task,\n        uint256 _expiryDate\n    )\n        external;\n\n\n    /// @notice A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\n    ///  the next one, after they have been executed.\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _tasks This can be a single task or a sequence of tasks.\n    /// @param _expiryDate  After this no task of the sequence can be executed any more.\n    /// @param _cycles How many full cycles will be submitted\n    function submitTaskCycle(\n        Provider calldata _provider,\n        Task[] calldata _tasks,\n        uint256 _expiryDate,\n        uint256 _cycles\n    )\n        external;\n\n\n    /// @notice A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\n    ///  the next one, after they have been executed.\n    /// @dev CAUTION: _sumOfRequestedTaskSubmits does not mean the number of cycles.\n    /// @dev If _sumOfRequestedTaskSubmits = 1 && _tasks.length = 2, only the first task\n    ///  would be submitted, but not the second\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _tasks This can be a single task or a sequence of tasks.\n    /// @param _expiryDate  After this no task of the sequence can be executed any more.\n    /// @param _sumOfRequestedTaskSubmits The TOTAL number of Task auto-submits\n    ///  that should have occured once the cycle is complete:\n    ///  _sumOfRequestedTaskSubmits = 0 => One Task will resubmit the next Task infinitly\n    ///  _sumOfRequestedTaskSubmits = 1 => One Task will resubmit no other task\n    ///  _sumOfRequestedTaskSubmits = 2 => One Task will resubmit 1 other task\n    ///  ...\n    function submitTaskChain(\n        Provider calldata _provider,\n        Task[] calldata _tasks,\n        uint256 _expiryDate,\n        uint256 _sumOfRequestedTaskSubmits\n    )\n        external;\n\n    // ================  Exec Suite =========================\n    /// @notice Off-chain API for executors to check, if a TaskReceipt is executable\n    /// @dev GelatoCore checks this during execution, in order to safeguard the Conditions\n    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\n    /// @param _gasLimit Task.selfProviderGasLimit is used for SelfProviders. All other\n    ///  Providers must use gelatoMaxGas. If the _gasLimit is used by an Executor and the\n    ///  tx reverts, a refund is paid by the Provider and the TaskReceipt is annulated.\n    /// @param _execTxGasPrice Must be used by Executors. Gas Price fed by gelatoCore's\n    ///  Gas Price Oracle. Executors can query the current gelatoGasPrice from events.\n    function canExec(TaskReceipt calldata _TR, uint256 _gasLimit, uint256 _execTxGasPrice)\n        external\n        view\n        returns(string memory);\n\n    /// @notice Executors call this when Conditions allow it to execute submitted Tasks.\n    /// @dev Executors get rewarded for successful Execution. The Task remains open until\n    ///   successfully executed, or when the execution failed, despite of gelatoMaxGas usage.\n    ///   In the latter case Executors are refunded by the Task Provider.\n    /// @param _TR TaskReceipt: id, userProxy, Task.\n    function exec(TaskReceipt calldata _TR) external;\n\n    /// @notice Cancel task\n    /// @dev Callable only by userProxy or selected provider\n    /// @param _TR TaskReceipt: id, userProxy, Task.\n    function cancelTask(TaskReceipt calldata _TR) external;\n\n    /// @notice Cancel multiple tasks at once\n    /// @dev Callable only by userProxy or selected provider\n    /// @param _taskReceipts TaskReceipts: id, userProxy, Task.\n    function multiCancelTasks(TaskReceipt[] calldata _taskReceipts) external;\n\n    /// @notice Compute hash of task receipt\n    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\n    /// @return hash of taskReceipt\n    function hashTaskReceipt(TaskReceipt calldata _TR) external pure returns(bytes32);\n\n    // ================  Getters =========================\n    /// @notice Returns the taskReceiptId of the last TaskReceipt submitted\n    /// @return currentId currentId, last TaskReceiptId submitted\n    function currentTaskReceiptId() external view returns(uint256);\n\n    /// @notice Returns computed taskReceipt hash, used to check for taskReceipt validity\n    /// @param _taskReceiptId Id of taskReceipt emitted in submission event\n    /// @return hash of taskReceipt\n    function taskReceiptHash(uint256 _taskReceiptId) external view returns(bytes32);\n}\n"
    },
    "contracts/interfaces/gelato/IGelatoV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// solhint-disable\npragma solidity >=0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {\n    Action,\n    Provider,\n    Task,\n    DataFlow,\n    TaskReceipt\n} from \"@gelatonetwork/core/contracts/gelato_core/interfaces/IGelatoCore.sol\";\n\n// TaskSpec - Will be whitelised by providers and selected by users\nstruct TaskSpec {\n    IGelatoCondition[] conditions; // Address: optional AddressZero for self-conditional actions\n    Action[] actions;\n    uint256 gasPriceCeil;\n}\n\ninterface IGelatoV1 {\n    /// @notice API to query whether Task can be submitted successfully.\n    /// @dev In submitTask the msg.sender must be the same as _userProxy here.\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _userProxy The userProxy from which the task will be submitted.\n    /// @param _task Selected provider, conditions, actions, expiry date of the task\n    function canSubmitTask(\n        address _userProxy,\n        Provider calldata _provider,\n        Task calldata _task,\n        uint256 _expiryDate\n    ) external view returns (string memory);\n\n    /// @notice API to submit a single Task.\n    /// @dev You can let users submit multiple tasks at once by batching calls to this.\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _task A Gelato Task object: provider, conditions, actions.\n    /// @param _expiryDate From then on the task cannot be executed. 0 for infinity.\n    function submitTask(\n        Provider calldata _provider,\n        Task calldata _task,\n        uint256 _expiryDate\n    ) external;\n\n    /// @notice A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\n    ///  the next one, after they have been executed.\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _tasks This can be a single task or a sequence of tasks.\n    /// @param _expiryDate  After this no task of the sequence can be executed any more.\n    /// @param _cycles How many full cycles will be submitted\n    function submitTaskCycle(\n        Provider calldata _provider,\n        Task[] calldata _tasks,\n        uint256 _expiryDate,\n        uint256 _cycles\n    ) external;\n\n    /// @notice A Gelato Task Cycle consists of 1 or more Tasks that automatically submit\n    ///  the next one, after they have been executed.\n    /// @dev CAUTION: _sumOfRequestedTaskSubmits does not mean the number of cycles.\n    /// @dev If _sumOfRequestedTaskSubmits = 1 && _tasks.length = 2, only the first task\n    ///  would be submitted, but not the second\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _tasks This can be a single task or a sequence of tasks.\n    /// @param _expiryDate  After this no task of the sequence can be executed any more.\n    /// @param _sumOfRequestedTaskSubmits The TOTAL number of Task auto-submits\n    ///  that should have occured once the cycle is complete:\n    ///  _sumOfRequestedTaskSubmits = 0 => One Task will resubmit the next Task infinitly\n    ///  _sumOfRequestedTaskSubmits = 1 => One Task will resubmit no other task\n    ///  _sumOfRequestedTaskSubmits = 2 => One Task will resubmit 1 other task\n    ///  ...\n    function submitTaskChain(\n        Provider calldata _provider,\n        Task[] calldata _tasks,\n        uint256 _expiryDate,\n        uint256 _sumOfRequestedTaskSubmits\n    ) external;\n\n    // ================  Exec Suite =========================\n    /// @notice Off-chain API for executors to check, if a TaskReceipt is executable\n    /// @dev GelatoCore checks this during execution, in order to safeguard the Conditions\n    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\n    /// @param _gasLimit Task.selfProviderGasLimit is used for SelfProviders. All other\n    ///  Providers must use gelatoMaxGas. If the _gasLimit is used by an Executor and the\n    ///  tx reverts, a refund is paid by the Provider and the TaskReceipt is annulated.\n    /// @param _execTxGasPrice Must be used by Executors. Gas Price fed by gelatoCore's\n    ///  Gas Price Oracle. Executors can query the current gelatoGasPrice from events.\n    function canExec(\n        TaskReceipt calldata _TR,\n        uint256 _gasLimit,\n        uint256 _execTxGasPrice\n    ) external view returns (string memory);\n\n    /// @notice Executors call this when Conditions allow it to execute submitted Tasks.\n    /// @dev Executors get rewarded for successful Execution. The Task remains open until\n    ///   successfully executed, or when the execution failed, despite of gelatoMaxGas usage.\n    ///   In the latter case Executors are refunded by the Task Provider.\n    /// @param _TR TaskReceipt: id, userProxy, Task.\n    function exec(TaskReceipt calldata _TR) external;\n\n    /// @notice Cancel task\n    /// @dev Callable only by userProxy or selected provider\n    /// @param _TR TaskReceipt: id, userProxy, Task.\n    function cancelTask(TaskReceipt calldata _TR) external;\n\n    /// @notice Cancel multiple tasks at once\n    /// @dev Callable only by userProxy or selected provider\n    /// @param _taskReceipts TaskReceipts: id, userProxy, Task.\n    function multiCancelTasks(TaskReceipt[] calldata _taskReceipts) external;\n\n    /// @notice Compute hash of task receipt\n    /// @param _TR TaskReceipt, consisting of user task, user proxy address and id\n    /// @return hash of taskReceipt\n    function hashTaskReceipt(TaskReceipt calldata _TR)\n        external\n        pure\n        returns (bytes32);\n\n    // ================  Getters =========================\n    /// @notice Returns the taskReceiptId of the last TaskReceipt submitted\n    /// @return currentId currentId, last TaskReceiptId submitted\n    function currentTaskReceiptId() external view returns (uint256);\n\n    /// @notice Returns computed taskReceipt hash, used to check for taskReceipt validity\n    /// @param _taskReceiptId Id of taskReceipt emitted in submission event\n    /// @return hash of taskReceipt\n    function taskReceiptHash(uint256 _taskReceiptId)\n        external\n        view\n        returns (bytes32);\n\n    /// @notice Stake on Gelato to become a whitelisted executor\n    /// @dev Msg.value has to be >= minExecutorStake\n    function stakeExecutor() external payable;\n\n    /// @notice Unstake on Gelato to become de-whitelisted and withdraw minExecutorStake\n    function unstakeExecutor() external;\n\n    /// @notice Re-assigns multiple providers to other executors\n    /// @dev Executors must re-assign all providers before being able to unstake\n    /// @param _providers List of providers to re-assign\n    /// @param _newExecutor Address of new executor to assign providers to\n    function multiReassignProviders(\n        address[] calldata _providers,\n        address _newExecutor\n    ) external;\n\n    /// @notice Withdraw excess Execur Stake\n    /// @dev Can only be called if executor is isExecutorMinStaked\n    /// @param _withdrawAmount Amount to withdraw\n    /// @return Amount that was actually withdrawn\n    function withdrawExcessExecutorStake(uint256 _withdrawAmount)\n        external\n        returns (uint256);\n\n    // =========== GELATO PROVIDER APIs ==============\n\n    /// @notice Validation that checks whether Task Spec is being offered by the selected provider\n    /// @dev Checked in submitTask(), unless provider == userProxy\n    /// @param _provider Address of selected provider\n    /// @param _taskSpec Task Spec\n    /// @return Expected to return \"OK\"\n    function isTaskSpecProvided(address _provider, TaskSpec calldata _taskSpec)\n        external\n        view\n        returns (string memory);\n\n    /// @notice Validates that provider has provider module whitelisted + conducts isProvided check in ProviderModule\n    /// @dev Checked in submitTask() if provider == userProxy\n    /// @param _userProxy userProxy passed by GelatoCore during submission and exec\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _task Task defined in IGelatoCore\n    /// @return Expected to return \"OK\"\n    function providerModuleChecks(\n        address _userProxy,\n        Provider calldata _provider,\n        Task calldata _task\n    ) external view returns (string memory);\n\n    /// @notice Validate if provider module and seleced TaskSpec is whitelisted by provider\n    /// @dev Combines \"isTaskSpecProvided\" and providerModuleChecks\n    /// @param _userProxy userProxy passed by GelatoCore during submission and exec\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _task Task defined in IGelatoCore\n    /// @return res Expected to return \"OK\"\n    function isTaskProvided(\n        address _userProxy,\n        Provider calldata _provider,\n        Task calldata _task\n    ) external view returns (string memory res);\n\n    /// @notice Validate if selected TaskSpec is whitelisted by provider and that current gelatoGasPrice is below GasPriceCeil\n    /// @dev If gasPriceCeil is != 0, Task Spec is whitelisted\n    /// @param _userProxy userProxy passed by GelatoCore during submission and exec\n    /// @param _provider Gelato Provider object: provider address and module.\n    /// @param _task Task defined in IGelatoCore\n    /// @param _gelatoGasPrice Task Receipt defined in IGelatoCore\n    /// @return res Expected to return \"OK\"\n    function providerCanExec(\n        address _userProxy,\n        Provider calldata _provider,\n        Task calldata _task,\n        uint256 _gelatoGasPrice\n    ) external view returns (string memory res);\n\n    // =========== PROVIDER STATE WRITE APIs ==============\n    // Provider Funding\n    /// @notice Deposit ETH as provider on Gelato\n    /// @param _provider Address of provider who receives ETH deposit\n    function provideFunds(address _provider) external payable;\n\n    /// @notice Withdraw provider funds from gelato\n    /// @param _withdrawAmount Amount\n    /// @return amount that will be withdrawn\n    function unprovideFunds(uint256 _withdrawAmount) external returns (uint256);\n\n    /// @notice Assign executor as provider\n    /// @param _executor Address of new executor\n    function providerAssignsExecutor(address _executor) external;\n\n    /// @notice Assign executor as previous selected executor\n    /// @param _provider Address of provider whose executor to change\n    /// @param _newExecutor Address of new executor\n    function executorAssignsExecutor(address _provider, address _newExecutor)\n        external;\n\n    // (Un-)provide Task Spec\n\n    /// @notice Whitelist TaskSpecs (A combination of a Condition, Action(s) and a gasPriceCeil) that users can select from\n    /// @dev If gasPriceCeil is == 0, Task Spec will be executed at any gas price (no ceil)\n    /// @param _taskSpecs Task Receipt List defined in IGelatoCore\n    function provideTaskSpecs(TaskSpec[] calldata _taskSpecs) external;\n\n    /// @notice De-whitelist TaskSpecs (A combination of a Condition, Action(s) and a gasPriceCeil) that users can select from\n    /// @dev If gasPriceCeil was set to NO_CEIL, Input NO_CEIL constant as GasPriceCeil\n    /// @param _taskSpecs Task Receipt List defined in IGelatoCore\n    function unprovideTaskSpecs(TaskSpec[] calldata _taskSpecs) external;\n\n    /// @notice Update gasPriceCeil of selected Task Spec\n    /// @param _taskSpecHash Result of hashTaskSpec()\n    /// @param _gasPriceCeil New gas price ceil for Task Spec\n    function setTaskSpecGasPriceCeil(\n        bytes32 _taskSpecHash,\n        uint256 _gasPriceCeil\n    ) external;\n\n    // Provider Module\n    /// @notice Whitelist new provider Module(s)\n    /// @param _modules Addresses of the modules which will be called during providerModuleChecks()\n    function addProviderModules(IGelatoProviderModule[] calldata _modules)\n        external;\n\n    /// @notice De-Whitelist new provider Module(s)\n    /// @param _modules Addresses of the modules which will be removed\n    function removeProviderModules(IGelatoProviderModule[] calldata _modules)\n        external;\n\n    // Batch (un-)provide\n\n    /// @notice Whitelist new executor, TaskSpec(s) and Module(s) in one tx\n    /// @param _executor Address of new executor of provider\n    /// @param _taskSpecs List of Task Spec which will be whitelisted by provider\n    /// @param _modules List of module addresses which will be whitelisted by provider\n    function multiProvide(\n        address _executor,\n        TaskSpec[] calldata _taskSpecs,\n        IGelatoProviderModule[] calldata _modules\n    ) external payable;\n\n    /// @notice De-Whitelist TaskSpec(s), Module(s) and withdraw funds from gelato in one tx\n    /// @param _withdrawAmount Amount to withdraw from ProviderFunds\n    /// @param _taskSpecs List of Task Spec which will be de-whitelisted by provider\n    /// @param _modules List of module addresses which will be de-whitelisted by provider\n    function multiUnprovide(\n        uint256 _withdrawAmount,\n        TaskSpec[] calldata _taskSpecs,\n        IGelatoProviderModule[] calldata _modules\n    ) external;\n\n    // =========== PROVIDER STATE READ APIs ==============\n    // Provider Funding\n\n    /// @notice Get balance of provider\n    /// @param _provider Address of provider\n    /// @return Provider Balance\n    function providerFunds(address _provider) external view returns (uint256);\n\n    /// @notice Get min stake required by all providers for executors to call exec\n    /// @param _gelatoMaxGas Current gelatoMaxGas\n    /// @param _gelatoGasPrice Current gelatoGasPrice\n    /// @return How much provider balance is required for executor to submit exec tx\n    function minExecProviderFunds(\n        uint256 _gelatoMaxGas,\n        uint256 _gelatoGasPrice\n    ) external view returns (uint256);\n\n    /// @notice Check if provider has sufficient funds for executor to call exec\n    /// @param _provider Address of provider\n    /// @param _gelatoMaxGas Currentt gelatoMaxGas\n    /// @param _gelatoGasPrice Current gelatoGasPrice\n    /// @return Whether provider is liquid (true) or not (false)\n    function isProviderLiquid(\n        address _provider,\n        uint256 _gelatoMaxGas,\n        uint256 _gelatoGasPrice\n    ) external view returns (bool);\n\n    // Executor Stake\n\n    /// @notice Get balance of executor\n    /// @param _executor Address of executor\n    /// @return Executor Balance\n    function executorStake(address _executor) external view returns (uint256);\n\n    /// @notice Check if executor has sufficient stake on gelato\n    /// @param _executor Address of provider\n    /// @return Whether executor has sufficient stake (true) or not (false)\n    function isExecutorMinStaked(address _executor)\n        external\n        view\n        returns (bool);\n\n    /// @notice Get executor of provider\n    /// @param _provider Address of provider\n    /// @return Provider's executor\n    function executorByProvider(address _provider)\n        external\n        view\n        returns (address);\n\n    /// @notice Get num. of providers which haved assigned an executor\n    /// @param _executor Address of executor\n    /// @return Count of how many providers assigned the executor\n    function executorProvidersCount(address _executor)\n        external\n        view\n        returns (uint256);\n\n    /// @notice Check if executor has one or more providers assigned\n    /// @param _executor Address of provider\n    /// @return Where 1 or more providers have assigned the executor\n    function isExecutorAssigned(address _executor) external view returns (bool);\n\n    // Task Spec and Gas Price Ceil\n    /// @notice The maximum gas price the transaction will be executed with\n    /// @param _provider Address of provider\n    /// @param _taskSpecHash Hash of provider TaskSpec\n    /// @return Max gas price an executor will execute the transaction with in wei\n    function taskSpecGasPriceCeil(address _provider, bytes32 _taskSpecHash)\n        external\n        view\n        returns (uint256);\n\n    /// @notice Returns the hash of the formatted TaskSpec.\n    /// @dev The action.data field of each Action is stripped before hashing.\n    /// @param _taskSpec TaskSpec\n    /// @return keccak256 hash of encoded condition address and Action List\n    function hashTaskSpec(TaskSpec calldata _taskSpec)\n        external\n        view\n        returns (bytes32);\n\n    /// @notice Constant used to specify the highest gas price available in the gelato system\n    /// @dev Input 0 as gasPriceCeil and it will be assigned to NO_CEIL\n    /// @return MAX_UINT\n    function NO_CEIL() external pure returns (uint256);\n\n    // Providers' Module Getters\n\n    /// @notice Check if inputted module is whitelisted by provider\n    /// @param _provider Address of provider\n    /// @param _module Address of module\n    /// @return true if it is whitelisted\n    function isModuleProvided(address _provider, IGelatoProviderModule _module)\n        external\n        view\n        returns (bool);\n\n    /// @notice Get all whitelisted provider modules from a given provider\n    /// @param _provider Address of provider\n    /// @return List of whitelisted provider modules\n    function providerModules(address _provider)\n        external\n        view\n        returns (IGelatoProviderModule[] memory);\n\n    // State Writing\n\n    /// @notice Assign new gas price oracle\n    /// @dev Only callable by sysAdmin\n    /// @param _newOracle Address of new oracle\n    function setGelatoGasPriceOracle(address _newOracle) external;\n\n    /// @notice Assign new gas price oracle\n    /// @dev Only callable by sysAdmin\n    /// @param _requestData The encoded payload for the staticcall to the oracle.\n    function setOracleRequestData(bytes calldata _requestData) external;\n\n    /// @notice Assign new maximum gas limit providers can consume in executionWrapper()\n    /// @dev Only callable by sysAdmin\n    /// @param _newMaxGas New maximum gas limit\n    function setGelatoMaxGas(uint256 _newMaxGas) external;\n\n    /// @notice Assign new interal gas limit requirement for exec()\n    /// @dev Only callable by sysAdmin\n    /// @param _newRequirement New internal gas requirement\n    function setInternalGasRequirement(uint256 _newRequirement) external;\n\n    /// @notice Assign new minimum executor stake\n    /// @dev Only callable by sysAdmin\n    /// @param _newMin New minimum executor stake\n    function setMinExecutorStake(uint256 _newMin) external;\n\n    /// @notice Assign new success share for executors to receive after successful execution\n    /// @dev Only callable by sysAdmin\n    /// @param _percentage New % success share of total gas consumed\n    function setExecutorSuccessShare(uint256 _percentage) external;\n\n    /// @notice Assign new success share for sysAdmin to receive after successful execution\n    /// @dev Only callable by sysAdmin\n    /// @param _percentage New % success share of total gas consumed\n    function setSysAdminSuccessShare(uint256 _percentage) external;\n\n    /// @notice Withdraw sysAdmin funds\n    /// @dev Only callable by sysAdmin\n    /// @param _amount Amount to withdraw\n    /// @param _to Address to receive the funds\n    function withdrawSysAdminFunds(uint256 _amount, address payable _to)\n        external\n        returns (uint256);\n\n    // State Reading\n    /// @notice Unaccounted tx overhead that will be refunded to executors\n    function EXEC_TX_OVERHEAD() external pure returns (uint256);\n\n    /// @notice Addess of current Gelato Gas Price Oracle\n    function gelatoGasPriceOracle() external view returns (address);\n\n    /// @notice Getter for oracleRequestData state variable\n    function oracleRequestData() external view returns (bytes memory);\n\n    /// @notice Gas limit an executor has to submit to get refunded even if actions revert\n    function gelatoMaxGas() external view returns (uint256);\n\n    /// @notice Internal gas limit requirements ti ensure executor payout\n    function internalGasRequirement() external view returns (uint256);\n\n    /// @notice Minimum stake required from executors\n    function minExecutorStake() external view returns (uint256);\n\n    /// @notice % Fee executors get as a reward for a successful execution\n    function executorSuccessShare() external view returns (uint256);\n\n    /// @notice Total % Fee executors and sysAdmin collectively get as a reward for a successful execution\n    /// @dev Saves a state read\n    function totalSuccessShare() external view returns (uint256);\n\n    /// @notice Get total fee providers pay executors for a successful execution\n    /// @param _gas Gas consumed by transaction\n    /// @param _gasPrice Current gelato gas price\n    function executorSuccessFee(uint256 _gas, uint256 _gasPrice)\n        external\n        view\n        returns (uint256);\n\n    /// @notice % Fee sysAdmin gets as a reward for a successful execution\n    function sysAdminSuccessShare() external view returns (uint256);\n\n    /// @notice Get total fee providers pay sysAdmin for a successful execution\n    /// @param _gas Gas consumed by transaction\n    /// @param _gasPrice Current gelato gas price\n    function sysAdminSuccessFee(uint256 _gas, uint256 _gasPrice)\n        external\n        view\n        returns (uint256);\n\n    /// @notice Get sysAdminds funds\n    function sysAdminFunds() external view returns (uint256);\n}\n\n/// @title IGelatoCondition - solidity interface of GelatoConditionsStandard\n/// @notice all the APIs of GelatoConditionsStandard\n/// @dev all the APIs are implemented inside GelatoConditionsStandard\ninterface IGelatoCondition {\n    /// @notice GelatoCore calls this to verify securely the specified Condition securely\n    /// @dev Be careful only to encode a Task's condition.data as is and not with the\n    ///  \"ok\" selector or _taskReceiptId, since those two things are handled by GelatoCore.\n    /// @param _taskReceiptId This is passed by GelatoCore so we can rely on it as a secure\n    ///  source of Task identification.\n    /// @param _conditionData This is the Condition.data field developers must encode their\n    ///  Condition's specific parameters in.\n    /// @param _cycleId For Tasks that are executed as part of a cycle.\n    function ok(\n        uint256 _taskReceiptId,\n        bytes calldata _conditionData,\n        uint256 _cycleId\n    ) external view returns (string memory);\n}\n\n/// @notice all the APIs and events of GelatoActionsStandard\n/// @dev all the APIs are implemented inside GelatoActionsStandard\ninterface IGelatoAction {\n    /// @notice Providers can use this for pre-execution sanity checks, to prevent reverts.\n    /// @dev GelatoCore checks this in canExec and passes the parameters.\n    /// @param _taskReceiptId The id of the task from which all arguments are passed.\n    /// @param _userProxy The userProxy of the task. Often address(this) for delegatecalls.\n    /// @param _actionData The encoded payload to be used in the Action.\n    /// @param _dataFlow The dataFlow of the Action.\n    /// @param _value A special param for ETH sending Actions. If the Action sends ETH\n    ///  in its Action function implementation, one should expect msg.value therein to be\n    ///  equal to _value. So Providers can check in termsOk that a valid ETH value will\n    ///  be used because they also have access to the same value when encoding the\n    ///  execPayload on their ProviderModule.\n    /// @param _cycleId For tasks that are part of a Cycle.\n    /// @return Returns OK, if Task can be executed safely according to the Provider's\n    ///  terms laid out in this function implementation.\n    function termsOk(\n        uint256 _taskReceiptId,\n        address _userProxy,\n        bytes calldata _actionData,\n        DataFlow _dataFlow,\n        uint256 _value,\n        uint256 _cycleId\n    ) external view returns (string memory);\n}\n\ninterface IGelatoProviderModule {\n    /// @notice Check if provider agrees to pay for inputted task receipt\n    /// @dev Enables arbitrary checks by provider\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\n    /// @param _provider The account of the Provider who uses the ProviderModule.\n    /// @param _task Gelato Task to be executed.\n    /// @return \"OK\" if provider agrees\n    function isProvided(\n        address _userProxy,\n        address _provider,\n        Task calldata _task\n    ) external view returns (string memory);\n\n    /// @notice Convert action specific payload into proxy specific payload\n    /// @dev Encoded multiple actions into a multisend\n    /// @param _taskReceiptId Unique ID of Gelato Task to be executed.\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\n    /// @param _provider The account of the Provider who uses the ProviderModule.\n    /// @param _task Gelato Task to be executed.\n    /// @param _cycleId For Tasks that form part of a cycle/chain.\n    /// @return Encoded payload that will be used for low-level .call on user proxy\n    /// @return checkReturndata if true, fwd returndata from userProxy.call to ProviderModule\n    function execPayload(\n        uint256 _taskReceiptId,\n        address _userProxy,\n        address _provider,\n        Task calldata _task,\n        uint256 _cycleId\n    ) external view returns (bytes memory, bool checkReturndata);\n\n    /// @notice Called by GelatoCore.exec to verifiy that no revert happend on userProxy\n    /// @dev If a caught revert is detected, this fn should revert with the detected error\n    /// @param _proxyReturndata Data from GelatoCore._exec.userProxy.call(execPayload)\n    function execRevertCheck(bytes calldata _proxyReturndata) external pure;\n}\n"
    },
    "@gelatonetwork/core/contracts/gelato_provider_modules/IGelatoProviderModule.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity >=0.6.10;\npragma experimental ABIEncoderV2;\n\nimport {Action, Task} from \"../gelato_core/interfaces/IGelatoCore.sol\";\n\ninterface IGelatoProviderModule {\n\n    /// @notice Check if provider agrees to pay for inputted task receipt\n    /// @dev Enables arbitrary checks by provider\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\n    /// @param _provider The account of the Provider who uses the ProviderModule.\n    /// @param _task Gelato Task to be executed.\n    /// @return \"OK\" if provider agrees\n    function isProvided(address _userProxy, address _provider, Task calldata _task)\n        external\n        view\n        returns(string memory);\n\n    /// @notice Convert action specific payload into proxy specific payload\n    /// @dev Encoded multiple actions into a multisend\n    /// @param _taskReceiptId Unique ID of Gelato Task to be executed.\n    /// @param _userProxy The smart contract account of the user who submitted the Task.\n    /// @param _provider The account of the Provider who uses the ProviderModule.\n    /// @param _task Gelato Task to be executed.\n    /// @param _cycleId For Tasks that form part of a cycle/chain.\n    /// @return Encoded payload that will be used for low-level .call on user proxy\n    /// @return checkReturndata if true, fwd returndata from userProxy.call to ProviderModule\n    function execPayload(\n        uint256 _taskReceiptId,\n        address _userProxy,\n        address _provider,\n        Task calldata _task,\n        uint256 _cycleId\n    )\n        external\n        view\n        returns(bytes memory, bool checkReturndata);\n\n    /// @notice Called by GelatoCore.exec to verifiy that no revert happend on userProxy\n    /// @dev If a caught revert is detected, this fn should revert with the detected error\n    /// @param _proxyReturndata Data from GelatoCore._exec.userProxy.call(execPayload)\n    function execRevertCheck(bytes calldata _proxyReturndata) external pure;\n}\n"
    },
    "@gelatonetwork/core/contracts/gelato_conditions/IGelatoCondition.sol": {
      "content": "// \"SPDX-License-Identifier: UNLICENSED\"\npragma solidity >=0.6.10;\npragma experimental ABIEncoderV2;\n\n/// @title IGelatoCondition - solidity interface of GelatoConditionsStandard\n/// @notice all the APIs of GelatoConditionsStandard\n/// @dev all the APIs are implemented inside GelatoConditionsStandard\ninterface IGelatoCondition {\n\n    /// @notice GelatoCore calls this to verify securely the specified Condition securely\n    /// @dev Be careful only to encode a Task's condition.data as is and not with the\n    ///  \"ok\" selector or _taskReceiptId, since those two things are handled by GelatoCore.\n    /// @param _taskReceiptId This is passed by GelatoCore so we can rely on it as a secure\n    ///  source of Task identification.\n    /// @param _conditionData This is the Condition.data field developers must encode their\n    ///  Condition's specific parameters in.\n    /// @param _cycleId For Tasks that are executed as part of a cycle.\n    function ok(uint256 _taskReceiptId, bytes calldata _conditionData, uint256 _cycleId)\n        external\n        view\n        returns(string memory);\n}"
    },
    "contracts/GelatoDCA.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {wdiv} from \"./vendor/DSMath.sol\";\nimport {\n    IERC20,\n    SafeERC20\n} from \"./vendor/openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {\n    ReentrancyGuard\n} from \"./vendor/openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {Utils} from \"./vendor/kyber/utils/Utils.sol\";\nimport {IKyberProxy} from \"./vendor/kyber/utils/IKyberProxy.sol\";\nimport {\n    IChainlinkOracle\n} from \"./interfaces/chainlink/IChainlinkOracle.sol\";\nimport {IOracleAggregator} from \"./interfaces/gelato/IOracleAggregator.sol\";\nimport {ITaskStorage} from \"./interfaces/gelato/ITaskStorage.sol\";\nimport {\n    IUniswapV2Router02\n} from \"./interfaces/uniswap/IUniswapV2Router02.sol\";\nimport {_to18Decimals} from \"./gelato/functions/FToken.sol\";\nimport {SimpleServiceStandard} from \"./gelato/standards/SimpleServiceStandard.sol\";\nimport {_transferEthOrToken} from \"./gelato/functions/FPayment.sol\";\nimport {ETH} from \"./gelato/constants/CTokens.sol\";\nimport {Fee} from \"./gelato/structs/SGelato.sol\";\nimport {IGelato} from \"./interfaces/gelato/IGelato.sol\";\n\ncontract GelatoDCA is SimpleServiceStandard, ReentrancyGuard, Utils {\n    using SafeERC20 for IERC20;\n\n    struct SubmitOrder {\n        address inToken;\n        address outToken;\n        uint256 amountPerTrade;\n        uint256 numTrades;\n        uint256 minSlippage;\n        uint256 maxSlippage;\n        uint256 delay;\n        address platformWallet;\n        uint256 platformFeeBps;\n    }\n\n    struct ExecOrder {\n        address user;\n        address inToken;\n        address outToken;\n        uint256 amountPerTrade;\n        uint256 nTradesLeft;\n        uint256 minSlippage;\n        uint256 maxSlippage;\n        uint256 delay;\n        uint256 lastExecutionTime;\n        address platformWallet;\n        uint256 platformFeeBps;\n    }\n\n    enum Dex {KYBER, UNISWAP, SUSHISWAP}\n\n    bytes public constant HINT = \"\";\n    uint256 internal constant _MAX_AMOUNT = type(uint256).max;\n\n    IUniswapV2Router02 public immutable uniRouterV2;\n    IUniswapV2Router02 public immutable sushiRouterV2;\n    IKyberProxy public immutable kyberProxy;\n\n    mapping(address => mapping(address => uint256)) public platformWalletFees;\n\n    event LogTaskSubmitted(uint256 indexed id, ExecOrder order, bool isSubmitAndExec);\n    event LogTaskCancelled(uint256 indexed id, ExecOrder order);\n    event LogTaskUpdated(uint256 indexed id, ExecOrder order);\n    event LogDCATrade(uint256 indexed id, ExecOrder order, uint256 outAmount);\n    event ClaimedPlatformFees(\n        address[] wallets,\n        address[] tokens,\n        address claimer\n    );\n\n    constructor(\n        IKyberProxy _kyberProxy,\n        IUniswapV2Router02 _uniRouterV2,\n        IUniswapV2Router02 _sushiRouterV2,\n        address _gelato\n    ) SimpleServiceStandard(_gelato) {\n        kyberProxy = _kyberProxy;\n        uniRouterV2 = _uniRouterV2;\n        sushiRouterV2 = _sushiRouterV2;\n    }\n\n    function submit(SubmitOrder memory _order, bool _isSubmitAndExec)\n        public\n        payable\n        returns (ExecOrder memory order, uint256 id)\n    {\n        if (_order.inToken == ETH) {\n            uint256 value =\n                _isSubmitAndExec\n                    ? _order.amountPerTrade * (_order.numTrades + 1)\n                    : _order.amountPerTrade * _order.numTrades;\n            require(\n                msg.value == value,\n                \"GelatoDCA.submit: mismatching amount of ETH deposited\"\n            );\n        }\n        order =\n            ExecOrder({\n                user: msg.sender,\n                inToken: _order.inToken,\n                outToken: _order.outToken,\n                amountPerTrade: _order.amountPerTrade,\n                nTradesLeft: _order.numTrades,\n                minSlippage: _order.minSlippage,\n                maxSlippage: _order.maxSlippage,\n                delay: _order.delay, // solhint-disable-next-line not-rely-on-time\n                lastExecutionTime: block.timestamp,\n                platformWallet: _order.platformWallet,\n                platformFeeBps: _order.platformFeeBps\n            });\n\n        // store order\n        id = _storeOrder(order, _isSubmitAndExec);\n    }\n\n    // solhint-disable-next-line function-max-lines\n    function submitAndExec(\n        SubmitOrder memory _order,\n        Dex _protocol,\n        uint256 _minReturnOrRate,\n        address[] calldata _tradePath\n    ) external payable {\n        require(\n            _order.numTrades > 1,\n            \"GelatoDCA.submitAndExec: cycle must have 2 or more trades\"\n        );\n\n        // 1. Submit future orders\n        _order.numTrades = _order.numTrades - 1;\n        (ExecOrder memory order, uint256 id) = submit(_order, true);\n\n        // 2. Exec 1st Trade now\n        if (_order.inToken != ETH) {\n            IERC20(_order.inToken).safeTransferFrom(\n                msg.sender,\n                address(this),\n                _order.amountPerTrade\n            );\n            IERC20(_order.inToken).safeIncreaseAllowance(\n                getProtocolAddress(_protocol),\n                _order.amountPerTrade\n            );\n        }\n\n        uint256 received;\n        if (_protocol == Dex.KYBER) {\n            received = _doKyberTrade(\n                _order.inToken,\n                _order.outToken,\n                _order.amountPerTrade,\n                _minReturnOrRate,\n                payable(msg.sender),\n                payable(_order.platformWallet),\n                _order.platformFeeBps\n            );\n        } else {\n            received = _doUniswapTrade(\n                _protocol == Dex.UNISWAP ? uniRouterV2 : sushiRouterV2,\n                _tradePath,\n                _order.amountPerTrade,\n                _minReturnOrRate,\n                payable(msg.sender),\n                payable(_order.platformWallet),\n                _order.platformFeeBps\n            );\n        }\n        \n        emit LogDCATrade(id, order, received);\n    }\n\n    function cancel(ExecOrder calldata _order, uint256 _id)\n        external\n        nonReentrant\n    {\n        _removeTask(abi.encode(_order), _id, msg.sender);\n        if (_order.inToken == ETH) {\n            uint256 refundAmount = _order.amountPerTrade * _order.nTradesLeft;\n            (bool success, ) = _order.user.call{value: refundAmount}(\"\");\n            require(success, \"GelatoDCA.cancel: Could not refund ETH\");\n        }\n\n        emit LogTaskCancelled(_id, _order);\n    }\n\n    function claimPlatformFees(\n        address[] calldata _platformWallets,\n        address[] calldata _tokens\n    ) external nonReentrant {\n        for (uint256 i = 0; i < _platformWallets.length; i++) {\n            for (uint256 j = 0; j < _tokens.length; j++) {\n                uint256 fee =\n                    platformWalletFees[_platformWallets[i]][_tokens[j]];\n                if (fee > 1) {\n                    platformWalletFees[_platformWallets[i]][_tokens[j]] = 1;\n                    _transferEthOrToken(\n                        payable(_platformWallets[i]),\n                        _tokens[j],\n                        fee - 1\n                    );\n                }\n            }\n        }\n        emit ClaimedPlatformFees(_platformWallets, _tokens, msg.sender);\n    }\n\n    // solhint-disable-next-line function-max-lines\n    function exec(\n        ExecOrder calldata _order,\n        uint256 _id,\n        Dex _protocol,\n        Fee memory _fee,\n        address[] calldata _tradePath\n    )\n        external\n        gelatofy(\n            _fee.isOutToken ? _order.outToken : _order.inToken,\n            _order.user,\n            abi.encode(_order),\n            _id,\n            _fee.amount,\n            _fee.swapRate\n        )\n    {\n        // task cycle logic\n        if (_order.nTradesLeft > 1) {\n            _updateAndSubmitNextTask(_order, _id);\n        } else {\n            _removeTask(abi.encode(_order), _id, _order.user);\n        }\n\n        // action exec\n        uint256 outAmount;\n        if (_protocol == Dex.KYBER) {\n            outAmount = _actionKyber(_order, _fee.amount, _fee.isOutToken);\n        } else {\n            outAmount = _actionUniOrSushi(\n                _order,\n                _protocol,\n                _tradePath,\n                _fee.amount,\n                _fee.isOutToken\n            );\n        }\n\n        if (_fee.isOutToken) {\n            _transferEthOrToken(\n                payable(_order.user),\n                _order.outToken,\n                outAmount\n            );\n        }\n\n        emit LogDCATrade(_id, _order, outAmount);\n    }\n\n    function isTaskSubmitted(ExecOrder calldata _order, uint256 _id)\n        external\n        view\n        returns (bool)\n    {\n        return verifyTask(abi.encode(_order), _id, _order.user);\n    }\n\n    function getMinReturn(ExecOrder memory _order)\n        public\n        view\n        returns (uint256 minReturn)\n    {\n        // 4. Rate Check\n        (uint256 idealReturn, ) =\n            IOracleAggregator(IGelato(gelato).getOracleAggregator())\n                .getExpectedReturnAmount(\n                _order.amountPerTrade,\n                _order.inToken,\n                _order.outToken\n            );\n\n        require(\n            idealReturn > 0,\n            \"GelatoKrystal.getMinReturn: idealReturn cannot be 0\"\n        );\n\n        // check time (reverts if block.timestamp is below execTime)\n        uint256 timeSinceCanExec =\n            // solhint-disable-next-line not-rely-on-time\n            block.timestamp - (_order.lastExecutionTime + _order.delay);\n\n        uint256 minSlippageFactor = BPS - _order.minSlippage;\n        uint256 maxSlippageFactor = BPS - _order.maxSlippage;\n        uint256 slippage;\n        if (minSlippageFactor > timeSinceCanExec) {\n            slippage = minSlippageFactor - timeSinceCanExec;\n        }\n\n        if (maxSlippageFactor > slippage) {\n            slippage = maxSlippageFactor;\n        }\n\n        minReturn = (idealReturn * slippage) / BPS;\n    }\n\n    function isSwapPossible(address _inToken, address _outToken)\n        external\n        view\n        returns (bool isPossible)\n    {\n        (uint256 idealReturn, ) =\n            IOracleAggregator(IGelato(gelato).getOracleAggregator())\n                .getExpectedReturnAmount(1e18, _inToken, _outToken);\n        isPossible = idealReturn == 0 ? false : true;\n    }\n\n    // ############# PRIVATE #############\n    function _actionKyber(\n        ExecOrder memory _order,\n        uint256 _fee,\n        bool _outTokenFee\n    ) private returns (uint256 received) {\n        (uint256 inAmount, uint256 minReturn, address payable receiver) =\n            _preExec(_order, _fee, _outTokenFee, Dex.KYBER);\n\n        received = _doKyberTrade(\n            _order.inToken,\n            _order.outToken,\n            inAmount,\n            _getKyberRate(inAmount, minReturn, _order.inToken, _order.outToken),\n            receiver,\n            payable(_order.platformWallet),\n            _order.platformFeeBps\n        );\n\n        if (_outTokenFee) {\n            received = received - _fee;\n        }\n    }\n\n    function _doKyberTrade(\n        address _inToken,\n        address _outToken,\n        uint256 _inAmount,\n        uint256 _minRate,\n        address payable _receiver,\n        address payable _platformWallet,\n        uint256 _platformFeeBps\n    ) private returns (uint256 received) {\n        uint256 ethToSend = _inToken == ETH ? _inAmount : uint256(0);\n\n        received = kyberProxy.tradeWithHintAndFee{value: ethToSend}(\n            IERC20(_inToken),\n            _inAmount,\n            IERC20(_outToken),\n            _receiver,\n            _MAX_AMOUNT,\n            _minRate,\n            _platformWallet,\n            _platformFeeBps,\n            HINT\n        );\n    }\n\n    function _actionUniOrSushi(\n        ExecOrder memory _order,\n        Dex _protocol,\n        address[] memory _tradePath,\n        uint256 _fee,\n        bool _outTokenFee\n    ) private returns (uint256 received) {\n        (uint256 inAmount, uint256 minReturn, address payable receiver) =\n            _preExec(_order, _fee, _outTokenFee, _protocol);\n\n        require(\n            _order.inToken == _tradePath[0] &&\n                _order.outToken == _tradePath[_tradePath.length - 1],\n            \"GelatoDCA.action: trade path does not match order.\"\n        );\n\n        received = _doUniswapTrade(\n            _protocol == Dex.UNISWAP ? uniRouterV2 : sushiRouterV2,\n            _tradePath,\n            inAmount,\n            minReturn,\n            receiver,\n            payable(_order.platformWallet),\n            _order.platformFeeBps\n        );\n\n        if (_outTokenFee) {\n            received = received - _fee;\n        }\n    }\n\n    // @dev fee will always be paid be srcToken\n    // solhint-disable-next-line function-max-lines\n    function _doUniswapTrade(\n        IUniswapV2Router02 _router,\n        address[] memory _tradePath,\n        uint256 _inAmount,\n        uint256 _minReturn,\n        address payable _receiver,\n        address payable _platformWallet,\n        uint256 _platformFeeBps\n    ) private returns (uint256 received) {\n        uint256 feeAmount = (_inAmount * _platformFeeBps) / BPS;\n        uint256 actualSellAmount = _inAmount - feeAmount;\n        address actualInToken;\n        address actualOutToken;\n        {\n            uint256 tradeLen = _tradePath.length;\n            actualInToken = _tradePath[0];\n            actualOutToken = _tradePath[tradeLen - 1];\n            if (_tradePath[0] == address(ETH)) {\n                _tradePath[0] = _router.WETH();\n            }\n            if (_tradePath[tradeLen - 1] == address(ETH)) {\n                _tradePath[tradeLen - 1] = _router.WETH();\n            }\n\n            // add platform fee to platform wallet account\n            _addFeeToPlatform(_platformWallet, actualInToken, feeAmount);\n        }\n\n        uint256[] memory amounts;\n        if (actualInToken == ETH) {\n            amounts = _router.swapExactETHForTokens{value: actualSellAmount}(\n                _minReturn,\n                _tradePath,\n                _receiver,\n                _MAX_AMOUNT\n            );\n        } else {\n            if (actualOutToken == address(ETH)) {\n                amounts = _router.swapExactTokensForETH(\n                    actualSellAmount,\n                    _minReturn,\n                    _tradePath,\n                    _receiver,\n                    _MAX_AMOUNT\n                );\n            } else {\n                amounts = _router.swapExactTokensForTokens(\n                    actualSellAmount,\n                    _minReturn,\n                    _tradePath,\n                    _receiver,\n                    _MAX_AMOUNT\n                );\n            }\n        }\n\n        return amounts[amounts.length - 1];\n    }\n\n    // solhint-disable function-max-lines\n    function _preExec(\n        ExecOrder memory _order,\n        uint256 _fee,\n        bool _outTokenFee,\n        Dex _protocol\n    )\n        private\n        returns (\n            uint256 inAmount,\n            uint256 minReturn,\n            address payable receiver\n        )\n    {\n        if (_outTokenFee) {\n            receiver = payable(this);\n            minReturn = getMinReturn(_order) + _fee;\n            inAmount = _order.amountPerTrade;\n        } else {\n            receiver = payable(_order.user);\n            minReturn = getMinReturn(_order);\n            inAmount = _order.amountPerTrade - _fee;\n        }\n\n        if (_order.inToken != ETH) {\n            IERC20(_order.inToken).safeTransferFrom(\n                _order.user,\n                address(this),\n                _order.amountPerTrade\n            );\n            IERC20(_order.inToken).safeIncreaseAllowance(\n                getProtocolAddress(_protocol),\n                inAmount\n            );\n        }\n    }\n\n    function _updateAndSubmitNextTask(ExecOrder memory _order, uint256 _id)\n        private\n    {\n        bytes memory lastOrder = abi.encode(_order);\n        // update next order\n        _order.nTradesLeft = _order.nTradesLeft - 1;\n        // solhint-disable-next-line not-rely-on-time\n        _order.lastExecutionTime = block.timestamp;\n\n        _updateTask(lastOrder, abi.encode(_order), _id, _order.user);\n        emit LogTaskSubmitted(_id, _order, false);\n    }\n\n    function _storeOrder(ExecOrder memory _order, bool _isSubmitAndExec) private returns (uint256 id) {\n        id = _storeTask(abi.encode(_order), _order.user);\n        emit LogTaskSubmitted(id, _order, _isSubmitAndExec);\n    }\n\n    function _getKyberRate(\n        uint256 _amountIn,\n        uint256 _minReturn,\n        address _inToken,\n        address _outToken\n    ) private view returns (uint256) {\n        uint256 newAmountIn =\n            _to18Decimals(\n                _inToken,\n                _amountIn,\n                \"GelatoDCA:_getKyberRate: newAmountIn revert\"\n            );\n        uint256 newMinReturn =\n            _to18Decimals(\n                _outToken,\n                _minReturn,\n                \"GelatoDCA:_getKyberRate: newMinReturn revert\"\n            );\n        return wdiv(newMinReturn, newAmountIn);\n    }\n\n    function _addFeeToPlatform(\n        address _wallet,\n        address _token,\n        uint256 _amount\n    ) private {\n        if (_amount > 0) {\n            platformWalletFees[_wallet][_token] =\n                platformWalletFees[_wallet][_token] +\n                _amount;\n        }\n    }\n\n    function getProtocolAddress(Dex _dex) public view returns (address) {\n        if (_dex == Dex.KYBER) return address(kyberProxy);\n        if (_dex == Dex.UNISWAP) return address(uniRouterV2);\n        if (_dex == Dex.SUSHISWAP) return address(sushiRouterV2);\n        revert(\"GelatoDCA: getProtocolAddress: Dex not found\");\n    }\n\n    function getExpectedReturnKyber(\n        IERC20 _src,\n        IERC20 _dest,\n        uint256 _inAmount,\n        uint256 _platformFee,\n        bytes calldata _hint\n    ) external view returns (uint256 outAmount, uint256 expectedRate) {\n        try\n            kyberProxy.getExpectedRateAfterFee(\n                _src,\n                _dest,\n                _inAmount,\n                _platformFee,\n                _hint\n            )\n        returns (uint256 rate) {\n            expectedRate = rate;\n        } catch {\n            expectedRate = 0;\n        }\n        outAmount = calcDestAmount(_src, _dest, _inAmount, expectedRate);\n    }\n\n    function getExpectedReturnUniswap(\n        IUniswapV2Router02 _router,\n        uint256 _inAmount,\n        address[] calldata _tradePath,\n        uint256 _platformFee\n    ) external view returns (uint256 outAmount, uint256 expectedRate) {\n        if (_platformFee >= BPS) return (0, 0);\n        uint256 srcAmountAfterFee = (_inAmount * (BPS - _platformFee)) / BPS;\n        if (srcAmountAfterFee == 0) return (0, 0);\n\n        try _router.getAmountsOut(srcAmountAfterFee, _tradePath) returns (\n            uint256[] memory amounts\n        ) {\n            outAmount = amounts[_tradePath.length - 1];\n        } catch {\n            outAmount = 0;\n        }\n        expectedRate = calcRateFromQty(\n            srcAmountAfterFee,\n            outAmount,\n            getDecimals(IERC20(_tradePath[0])),\n            getDecimals(IERC20(_tradePath[_tradePath.length - 1]))\n        );\n    }\n}\n"
    },
    "contracts/vendor/utils/Utils.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {ETH} from \"../../gelato/constants/CTokens.sol\";\nimport {IERC20} from  \"../openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nfunction getBalance(address token, address user) view returns (uint256) {\n        if (token == ETH) {\n            return user.balance;\n        } else {\n            return IERC20(token).balanceOf(user);\n        }\n    }"
    },
    "contracts/vendor/openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view override returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender)\n        public\n        view\n        virtual\n        override\n        returns (uint256)\n    {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount)\n        public\n        virtual\n        override\n        returns (bool)\n    {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            _msgSender(),\n            _allowances[sender][_msgSender()].sub(\n                amount,\n                \"ERC20: transfer amount exceeds allowance\"\n            )\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].add(addedValue)\n        );\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue)\n        public\n        virtual\n        returns (bool)\n    {\n        _approve(\n            _msgSender(),\n            spender,\n            _allowances[_msgSender()][spender].sub(\n                subtractedValue,\n                \"ERC20: decreased allowance below zero\"\n            )\n        );\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(\n            amount,\n            \"ERC20: transfer amount exceeds balance\"\n        );\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(\n            amount,\n            \"ERC20: burn amount exceeds balance\"\n        );\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "contracts/vendor/openzeppelin/contracts/GSN/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address payable) {\n        return payable(msg.sender);\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/exchange/SmartWalletSwapImplementation.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport \"../interfaces/krystal/ISmartWalletSwapImplementation.sol\";\nimport \"./SmartWalletSwapStorage.sol\";\nimport {\n    IERC20\n} from \"../vendor/openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {\n    SafeERC20\n} from \"../vendor/openzeppelin/contracts/token/ERC20/SafeERC20.sol\";\nimport {\n    SafeMath\n} from \"../vendor/openzeppelin/contracts/math/SafeMath.sol\";\n\n// solhint-disable no-empty-blocks\n// solhint-disable private-vars-leading-underscore\n// solhint-disable function-max-lines\ncontract SmartWalletSwapImplementation is\n    SmartWalletSwapStorage,\n    ISmartWalletSwapImplementation\n{\n    using SafeERC20 for IERC20;\n    using SafeMath for uint256;\n\n    event UpdatedSupportedPlatformWallets(address[] wallets, bool isSupported);\n    event UpdatedBurnGasHelper(IBurnGasHelper indexed gasHelper);\n    event UpdatedLendingImplementation(ISmartWalletLending impl);\n    event ApprovedAllowances(IERC20[] tokens, address[] spenders, bool isReset);\n    event ClaimedPlatformFees(\n        address[] wallets,\n        IERC20[] tokens,\n        address claimer\n    );\n\n    constructor(address _admin) SmartWalletSwapStorage(_admin) {}\n\n    receive() external payable {}\n\n    function updateBurnGasHelper(IBurnGasHelper _burnGasHelper)\n        external\n        onlyAdmin\n    {\n        if (burnGasHelper != _burnGasHelper) {\n            burnGasHelper = _burnGasHelper;\n            emit UpdatedBurnGasHelper(_burnGasHelper);\n        }\n    }\n\n    function updateLendingImplementation(ISmartWalletLending newImpl)\n        external\n        onlyAdmin\n    {\n        require(\n            newImpl != ISmartWalletLending(address(0)),\n            \"invalid lending impl\"\n        );\n        lendingImpl = newImpl;\n        emit UpdatedLendingImplementation(newImpl);\n    }\n\n    /// @dev to prevent other integrations to call trade from this contract\n    function updateSupportedPlatformWallets(\n        address[] calldata wallets,\n        bool isSupported\n    ) external onlyAdmin {\n        for (uint256 i = 0; i < wallets.length; i++) {\n            supportedPlatformWallets[wallets[i]] = isSupported;\n        }\n        emit UpdatedSupportedPlatformWallets(wallets, isSupported);\n    }\n\n    function claimPlatformFees(\n        address[] calldata platformWallets,\n        IERC20[] calldata tokens\n    ) external override nonReentrant {\n        for (uint256 i = 0; i < platformWallets.length; i++) {\n            for (uint256 j = 0; j < tokens.length; j++) {\n                uint256 fee = platformWalletFees[platformWallets[i]][tokens[j]];\n                if (fee > 1) {\n                    platformWalletFees[platformWallets[i]][tokens[j]] = 1;\n                    transferToken(\n                        payable(platformWallets[i]),\n                        tokens[j],\n                        fee - 1\n                    );\n                }\n            }\n        }\n        emit ClaimedPlatformFees(platformWallets, tokens, msg.sender);\n    }\n\n    function approveAllowances(\n        IERC20[] calldata tokens,\n        address[] calldata spenders,\n        bool isReset\n    ) external onlyAdmin {\n        uint256 allowance = isReset ? 0 : MAX_ALLOWANCE;\n        for (uint256 i = 0; i < tokens.length; i++) {\n            for (uint256 j = 0; j < spenders.length; j++) {\n                tokens[i].safeApprove(spenders[j], allowance);\n            }\n            getSetDecimals(tokens[i]);\n        }\n\n        emit ApprovedAllowances(tokens, spenders, isReset);\n    }\n\n    /// ========== SWAP ========== ///\n\n    /// @dev swap token via Kyber\n    /// @notice for some tokens that are paying fee, for example: DGX\n    /// contract will trade with received src token amount (after minus fee)\n    /// for Kyber, fee will be taken in ETH as part of their feature\n    function swapKyber(\n        IERC20 src,\n        IERC20 dest,\n        uint256 srcAmount,\n        uint256 minConversionRate,\n        address payable recipient,\n        uint256 platformFeeBps,\n        address payable platformWallet,\n        bytes calldata hint,\n        bool useGasToken\n    ) external payable override nonReentrant returns (uint256 destAmount) {\n        uint256 gasBefore = useGasToken ? gasleft() : 0;\n        destAmount = doKyberTrade(\n            src,\n            dest,\n            srcAmount,\n            minConversionRate,\n            recipient,\n            platformFeeBps,\n            platformWallet,\n            hint\n        );\n        uint256 numGasBurns = 0;\n        // burn gas token if needed\n        if (useGasToken) {\n            numGasBurns = burnGasTokensAfter(gasBefore);\n        }\n        emit KyberTrade(\n            msg.sender,\n            src,\n            dest,\n            srcAmount,\n            destAmount,\n            recipient,\n            platformFeeBps,\n            platformWallet,\n            hint,\n            useGasToken,\n            numGasBurns\n        );\n    }\n\n    /// @dev swap token via a supported Uniswap router\n    /// @notice for some tokens that are paying fee, for example: DGX\n    /// contract will trade with received src token amount (after minus fee)\n    /// for Uniswap, fee will be taken in src token\n    function swapUniswap(\n        IUniswapV2Router02 router,\n        uint256 srcAmount,\n        uint256 minDestAmount,\n        address[] calldata tradePath,\n        address payable recipient,\n        uint256 platformFeeBps,\n        address payable platformWallet,\n        bool feeInSrc,\n        bool useGasToken\n    ) external payable override nonReentrant returns (uint256 destAmount) {\n        uint256 numGasBurns;\n        {\n            // prevent stack too deep\n            uint256 gasBefore = useGasToken ? gasleft() : 0;\n            destAmount = swapUniswapInternal(\n                router,\n                srcAmount,\n                minDestAmount,\n                tradePath,\n                recipient,\n                platformFeeBps,\n                platformWallet,\n                feeInSrc\n            );\n            if (useGasToken) {\n                numGasBurns = burnGasTokensAfter(gasBefore);\n            }\n        }\n\n        emit UniswapTrade(\n            msg.sender,\n            address(router),\n            tradePath,\n            srcAmount,\n            destAmount,\n            recipient,\n            platformFeeBps,\n            platformWallet,\n            feeInSrc,\n            useGasToken,\n            numGasBurns\n        );\n    }\n\n    /// ========== SWAP & DEPOSIT ========== ///\n\n    function swapKyberAndDeposit(\n        ISmartWalletLending.LendingPlatform platform,\n        IERC20 src,\n        IERC20 dest,\n        uint256 srcAmount,\n        uint256 minConversionRate,\n        uint256 platformFeeBps,\n        address payable platformWallet,\n        bytes calldata hint,\n        bool useGasToken\n    ) external payable override nonReentrant returns (uint256 destAmount) {\n        require(lendingImpl != ISmartWalletLending(address(0)));\n        uint256 gasBefore = useGasToken ? gasleft() : 0;\n        if (src == dest) {\n            // just collect src token, no need to swap\n            destAmount = safeForwardTokenAndCollectFee(\n                src,\n                msg.sender,\n                payable(address(lendingImpl)),\n                srcAmount,\n                platformFeeBps,\n                platformWallet\n            );\n        } else {\n            destAmount = doKyberTrade(\n                src,\n                dest,\n                srcAmount,\n                minConversionRate,\n                payable(address(lendingImpl)),\n                platformFeeBps,\n                platformWallet,\n                hint\n            );\n        }\n\n        // eth or token alr transferred to the address\n        lendingImpl.depositTo(platform, payable(msg.sender), dest, destAmount);\n\n        uint256 numGasBurns = 0;\n        if (useGasToken) {\n            numGasBurns = burnGasTokensAfter(gasBefore);\n        }\n\n        emit KyberTradeAndDeposit(\n            msg.sender,\n            platform,\n            src,\n            dest,\n            srcAmount,\n            destAmount,\n            platformFeeBps,\n            platformWallet,\n            hint,\n            useGasToken,\n            numGasBurns\n        );\n    }\n\n    /// @dev swap Uniswap then deposit to platform\n    ///     if tradePath has only 1 token, don't need to do swap\n    /// @param platform platform to deposit\n    /// @param router which Uni-clone to use for swapping\n    /// @param srcAmount amount of src token\n    /// @param minDestAmount minimal accepted dest amount\n    /// @param tradePath path of the trade on Uniswap\n    /// @param platformFeeBps fee if swapping\n    /// @param platformWallet wallet to receive fee\n    /// @param useGasToken whether to use gas token or not\n    function swapUniswapAndDeposit(\n        ISmartWalletLending.LendingPlatform platform,\n        IUniswapV2Router02 router,\n        uint256 srcAmount,\n        uint256 minDestAmount,\n        address[] calldata tradePath,\n        uint256 platformFeeBps,\n        address payable platformWallet,\n        bool useGasToken\n    ) external payable override nonReentrant returns (uint256 destAmount) {\n        require(lendingImpl != ISmartWalletLending(address(0)));\n        uint256 gasBefore = useGasToken ? gasleft() : 0;\n        {\n            IERC20 dest = IERC20(tradePath[tradePath.length - 1]);\n            if (tradePath.length == 1) {\n                // just collect src token, no need to swap\n                destAmount = safeForwardTokenAndCollectFee(\n                    dest,\n                    msg.sender,\n                    payable(address(lendingImpl)),\n                    srcAmount,\n                    platformFeeBps,\n                    platformWallet\n                );\n            } else {\n                destAmount = swapUniswapInternal(\n                    router,\n                    srcAmount,\n                    minDestAmount,\n                    tradePath,\n                    payable(address(lendingImpl)),\n                    platformFeeBps,\n                    platformWallet,\n                    false\n                );\n            }\n\n            // eth or token alr transferred to the address\n            lendingImpl.depositTo(\n                platform,\n                payable(msg.sender),\n                dest,\n                destAmount\n            );\n        }\n\n        uint256 numGasBurns = 0;\n        if (useGasToken) {\n            numGasBurns = burnGasTokensAfter(gasBefore);\n        }\n\n        emit UniswapTradeAndDeposit(\n            msg.sender,\n            platform,\n            router,\n            tradePath,\n            srcAmount,\n            destAmount,\n            platformFeeBps,\n            platformWallet,\n            useGasToken,\n            numGasBurns\n        );\n    }\n\n    /// @dev withdraw token from Lending platforms (AAVE, COMPOUND)\n    /// @param platform platform to withdraw token\n    /// @param token underlying token to withdraw, e.g ETH, USDT, DAI\n    /// @param amount amount of cToken (COMPOUND) or aToken (AAVE) to withdraw\n    /// @param minReturn minimum amount of USDT tokens to return\n    /// @param useGasToken whether to use gas token or not\n    /// @return returnedAmount returns the amount withdrawn to the user\n    function withdrawFromLendingPlatform(\n        ISmartWalletLending.LendingPlatform platform,\n        IERC20 token,\n        uint256 amount,\n        uint256 minReturn,\n        bool useGasToken\n    ) external override nonReentrant returns (uint256 returnedAmount) {\n        require(lendingImpl != ISmartWalletLending(address(0)));\n        uint256 gasBefore = useGasToken ? gasleft() : 0;\n        IERC20 lendingToken =\n            IERC20(lendingImpl.getLendingToken(platform, token));\n        require(lendingToken != IERC20(address(0)), \"unsupported token\");\n        // AAVE aToken's transfer logic could have rounding errors\n        uint256 tokenBalanceBefore =\n            lendingToken.balanceOf(address(lendingImpl));\n        lendingToken.safeTransferFrom(msg.sender, address(lendingImpl), amount);\n        uint256 tokenBalanceAfter =\n            lendingToken.balanceOf(address(lendingImpl));\n\n        returnedAmount = lendingImpl.withdrawFrom(\n            platform,\n            payable(msg.sender),\n            token,\n            tokenBalanceAfter.sub(tokenBalanceBefore),\n            minReturn\n        );\n\n        uint256 numGasBurns;\n        if (useGasToken) {\n            numGasBurns = burnGasTokensAfter(gasBefore);\n        }\n        emit WithdrawFromLending(\n            platform,\n            token,\n            amount,\n            minReturn,\n            returnedAmount,\n            useGasToken,\n            numGasBurns\n        );\n    }\n\n    /// @dev swap on Kyber and repay borrow for sender\n    /// if src == dest, no need to swap, use src token to repay directly\n    /// @param payAmount: amount that user wants to pay, if the dest amount (after swap) is higher,\n    ///     the remain amount will be sent back to user's wallet\n    /// @param feeAndRateMode: in case of aave v2, user needs to specify the rateMode to repay\n    ///     to prevent stack too deep, combine fee and rateMode into a single value\n    ///     platformFee: feeAndRateMode % BPS, rateMode: feeAndRateMode / BPS\n    /// Other params are params for trade on Kyber\n    function swapKyberAndRepay(\n        ISmartWalletLending.LendingPlatform platform,\n        IERC20 src,\n        IERC20 dest,\n        uint256 srcAmount,\n        uint256 payAmount,\n        uint256 feeAndRateMode,\n        address payable platformWallet,\n        bytes calldata hint,\n        bool useGasToken\n    ) external payable override nonReentrant returns (uint256 destAmount) {\n        uint256 numGasBurns;\n        {\n            require(lendingImpl != ISmartWalletLending(address(0)));\n            uint256 gasBefore = useGasToken ? gasleft() : 0;\n\n            {\n                // use user debt value if debt is <= payAmount,\n                // user can pay all debt by putting really high payAmount as param\n                payAmount = checkUserDebt(platform, address(dest), payAmount);\n                if (src == dest) {\n                    if (src == ETH_TOKEN_ADDRESS) {\n                        require(msg.value == srcAmount, \"invalid msg value\");\n                        transferToken(\n                            payable(address(lendingImpl)),\n                            src,\n                            srcAmount\n                        );\n                    } else {\n                        destAmount = srcAmount > payAmount\n                            ? payAmount\n                            : srcAmount;\n                        src.safeTransferFrom(\n                            msg.sender,\n                            address(lendingImpl),\n                            destAmount\n                        );\n                    }\n                } else {\n                    // use user debt value if debt is <= payAmount\n                    payAmount = checkUserDebt(\n                        platform,\n                        address(dest),\n                        payAmount\n                    );\n\n                    // use min rate so it can return earlier if failed to swap\n                    uint256 minRate =\n                        calcRateFromQty(\n                            srcAmount,\n                            payAmount,\n                            src.decimals(),\n                            dest.decimals()\n                        );\n\n                    destAmount = doKyberTrade(\n                        src,\n                        dest,\n                        srcAmount,\n                        minRate,\n                        payable(address(lendingImpl)),\n                        feeAndRateMode % BPS,\n                        platformWallet,\n                        hint\n                    );\n                }\n            }\n\n            lendingImpl.repayBorrowTo(\n                platform,\n                payable(msg.sender),\n                dest,\n                destAmount,\n                payAmount,\n                feeAndRateMode / BPS\n            );\n\n            if (useGasToken) {\n                numGasBurns = burnGasTokensAfter(gasBefore);\n            }\n        }\n\n        emit KyberTradeAndRepay(\n            msg.sender,\n            platform,\n            src,\n            dest,\n            srcAmount,\n            destAmount,\n            payAmount,\n            feeAndRateMode,\n            platformWallet,\n            hint,\n            useGasToken,\n            numGasBurns\n        );\n    }\n\n    /// @dev swap on Uni-clone and repay borrow for sender\n    /// if tradePath.length == 1, no need to swap, use tradePath[0] token to repay directly\n    /// @param payAmount: amount that user wants to pay, if the dest amount (after swap) is higher,\n    ///     the remain amount will be sent back to user's wallet\n    /// @param feeAndRateMode: in case of aave v2, user needs to specify the rateMode to repay\n    ///     to prevent stack too deep, combine fee and rateMode into a single value\n    ///     platformFee: feeAndRateMode % BPS, rateMode: feeAndRateMode / BPS\n    /// Other params are params for trade on Uni-clone\n    function swapUniswapAndRepay(\n        ISmartWalletLending.LendingPlatform platform,\n        IUniswapV2Router02 router,\n        uint256 srcAmount,\n        uint256 payAmount,\n        address[] calldata tradePath,\n        uint256 feeAndRateMode,\n        address payable platformWallet,\n        bool useGasToken\n    ) external payable override nonReentrant returns (uint256 destAmount) {\n        uint256 numGasBurns;\n        {\n            // scope to prevent stack too deep\n            require(lendingImpl != ISmartWalletLending(address(0)));\n            uint256 gasBefore = useGasToken ? gasleft() : 0;\n            IERC20 dest = IERC20(tradePath[tradePath.length - 1]);\n\n            // use user debt value if debt is <= payAmount\n            // user can pay all debt by putting really high payAmount as param\n            payAmount = checkUserDebt(platform, address(dest), payAmount);\n            if (tradePath.length == 1) {\n                if (dest == ETH_TOKEN_ADDRESS) {\n                    require(msg.value == srcAmount, \"invalid msg value\");\n                    transferToken(\n                        payable(address(lendingImpl)),\n                        dest,\n                        srcAmount\n                    );\n                } else {\n                    destAmount = srcAmount > payAmount ? payAmount : srcAmount;\n                    dest.safeTransferFrom(\n                        msg.sender,\n                        address(lendingImpl),\n                        destAmount\n                    );\n                }\n            } else {\n                destAmount = swapUniswapInternal(\n                    router,\n                    srcAmount,\n                    payAmount,\n                    tradePath,\n                    payable(address(lendingImpl)),\n                    feeAndRateMode % BPS,\n                    platformWallet,\n                    false\n                );\n            }\n\n            lendingImpl.repayBorrowTo(\n                platform,\n                payable(msg.sender),\n                dest,\n                destAmount,\n                payAmount,\n                feeAndRateMode / BPS\n            );\n\n            if (useGasToken) {\n                numGasBurns = burnGasTokensAfter(gasBefore);\n            }\n        }\n\n        emit UniswapTradeAndRepay(\n            msg.sender,\n            platform,\n            router,\n            tradePath,\n            srcAmount,\n            destAmount,\n            payAmount,\n            feeAndRateMode,\n            platformWallet,\n            useGasToken,\n            numGasBurns\n        );\n    }\n\n    function claimComp(\n        address[] calldata holders,\n        ICompErc20[] calldata cTokens,\n        bool borrowers,\n        bool suppliers,\n        bool useGasToken\n    ) external override nonReentrant {\n        uint256 gasBefore = useGasToken ? gasleft() : 0;\n        lendingImpl.claimComp(holders, cTokens, borrowers, suppliers);\n        if (useGasToken) {\n            burnGasTokensAfter(gasBefore);\n        }\n    }\n\n    /// @dev get expected return and conversion rate if using Kyber\n    function getExpectedReturnKyber(\n        IERC20 src,\n        IERC20 dest,\n        uint256 srcAmount,\n        uint256 platformFee,\n        bytes calldata hint\n    )\n        external\n        view\n        override\n        returns (uint256 destAmount, uint256 expectedRate)\n    {\n        try\n            kyberProxy.getExpectedRateAfterFee(\n                src,\n                dest,\n                srcAmount,\n                platformFee,\n                hint\n            )\n        returns (uint256 rate) {\n            expectedRate = rate;\n        } catch {\n            expectedRate = 0;\n        }\n        destAmount = calcDestAmount(src, dest, srcAmount, expectedRate);\n    }\n\n    /// @dev get expected return and conversion rate if using a Uniswap router\n    function getExpectedReturnUniswap(\n        IUniswapV2Router02 router,\n        uint256 srcAmount,\n        address[] calldata tradePath,\n        uint256 platformFee\n    )\n        external\n        view\n        override\n        returns (uint256 destAmount, uint256 expectedRate)\n    {\n        if (platformFee >= BPS) return (0, 0); // platform fee is too high\n        if (!isRouterSupported[router]) return (0, 0); // router is not supported\n        uint256 srcAmountAfterFee = (srcAmount * (BPS - platformFee)) / BPS;\n        if (srcAmountAfterFee == 0) return (0, 0);\n        // in case pair is not supported\n        try router.getAmountsOut(srcAmountAfterFee, tradePath) returns (\n            uint256[] memory amounts\n        ) {\n            destAmount = amounts[tradePath.length - 1];\n        } catch {\n            destAmount = 0;\n        }\n        expectedRate = calcRateFromQty(\n            srcAmountAfterFee,\n            destAmount,\n            getDecimals(IERC20(tradePath[0])),\n            getDecimals(IERC20(tradePath[tradePath.length - 1]))\n        );\n    }\n\n    function checkUserDebt(\n        ISmartWalletLending.LendingPlatform platform,\n        address token,\n        uint256 amount\n    ) internal returns (uint256) {\n        uint256 debt =\n            lendingImpl.storeAndRetrieveUserDebtCurrent(\n                platform,\n                token,\n                msg.sender\n            );\n\n        if (debt >= amount) {\n            return amount;\n        }\n\n        return debt;\n    }\n\n    function doKyberTrade(\n        IERC20 src,\n        IERC20 dest,\n        uint256 srcAmount,\n        uint256 minConversionRate,\n        address payable recipient,\n        uint256 platformFeeBps,\n        address payable platformWallet,\n        bytes memory hint\n    ) internal virtual returns (uint256 destAmount) {\n        uint256 actualSrcAmount =\n            validateAndPrepareSourceAmount(\n                address(kyberProxy),\n                src,\n                srcAmount,\n                platformWallet\n            );\n        uint256 callValue = src == ETH_TOKEN_ADDRESS ? actualSrcAmount : 0;\n        destAmount = kyberProxy.tradeWithHintAndFee{value: callValue}(\n            src,\n            actualSrcAmount,\n            dest,\n            recipient,\n            MAX_AMOUNT,\n            minConversionRate,\n            platformWallet,\n            platformFeeBps,\n            hint\n        );\n    }\n\n    function swapUniswapInternal(\n        IUniswapV2Router02 router,\n        uint256 srcAmount,\n        uint256 minDestAmount,\n        address[] memory tradePath,\n        address payable recipient,\n        uint256 platformFeeBps,\n        address payable platformWallet,\n        bool feeInSrc\n    ) internal returns (uint256 destAmount) {\n        TradeInput memory input =\n            TradeInput({\n                srcAmount: srcAmount,\n                minData: minDestAmount,\n                recipient: recipient,\n                platformFeeBps: platformFeeBps,\n                platformWallet: platformWallet,\n                hint: \"\"\n            });\n\n        // extra validation when swapping on Uniswap\n        require(isRouterSupported[router], \"unsupported router\");\n        require(platformFeeBps < BPS, \"high platform fee\");\n\n        IERC20 src = IERC20(tradePath[0]);\n\n        input.srcAmount = validateAndPrepareSourceAmount(\n            address(router),\n            src,\n            srcAmount,\n            platformWallet\n        );\n\n        destAmount = doUniswapTrade(router, src, tradePath, input, feeInSrc);\n    }\n\n    // solhint-disable code-complexity\n    function doUniswapTrade(\n        IUniswapV2Router02 router,\n        IERC20 src,\n        address[] memory tradePath,\n        TradeInput memory input,\n        bool feeInSrc\n    ) internal virtual returns (uint256 destAmount) {\n        uint256 tradeLen = tradePath.length;\n        IERC20 actualDest = IERC20(tradePath[tradeLen - 1]);\n        {\n            // convert eth -> weth address to trade on Uniswap\n            if (tradePath[0] == address(ETH_TOKEN_ADDRESS)) {\n                tradePath[0] = router.WETH();\n            }\n            if (tradePath[tradeLen - 1] == address(ETH_TOKEN_ADDRESS)) {\n                tradePath[tradeLen - 1] = router.WETH();\n            }\n        }\n\n        uint256 srcAmountFee;\n        uint256 srcAmountAfterFee;\n        uint256 destBalanceBefore;\n        address recipient;\n\n        if (feeInSrc) {\n            srcAmountFee = input.srcAmount.mul(input.platformFeeBps).div(BPS);\n            srcAmountAfterFee = input.srcAmount.sub(srcAmountFee);\n            recipient = input.recipient;\n        } else {\n            srcAmountAfterFee = input.srcAmount;\n            destBalanceBefore = getBalance(actualDest, address(this));\n            recipient = address(this);\n        }\n\n        uint256[] memory amounts;\n        if (src == ETH_TOKEN_ADDRESS) {\n            // swap eth -> token\n            amounts = router.swapExactETHForTokens{value: srcAmountAfterFee}(\n                input.minData,\n                tradePath,\n                recipient,\n                MAX_AMOUNT\n            );\n        } else {\n            if (actualDest == ETH_TOKEN_ADDRESS) {\n                // swap token -> eth\n                amounts = router.swapExactTokensForETH(\n                    srcAmountAfterFee,\n                    input.minData,\n                    tradePath,\n                    recipient,\n                    MAX_AMOUNT\n                );\n            } else {\n                // swap token -> token\n                amounts = router.swapExactTokensForTokens(\n                    srcAmountAfterFee,\n                    input.minData,\n                    tradePath,\n                    recipient,\n                    MAX_AMOUNT\n                );\n            }\n        }\n\n        if (!feeInSrc) {\n            // fee in dest token, calculated received dest amount\n            uint256 destBalanceAfter = getBalance(actualDest, address(this));\n            destAmount = destBalanceAfter.sub(destBalanceBefore);\n            uint256 destAmountFee =\n                destAmount.mul(input.platformFeeBps).div(BPS);\n            // charge fee in dest token\n            addFeeToPlatform(input.platformWallet, actualDest, destAmountFee);\n            // transfer back dest token to recipient\n            destAmount = destAmount.sub(destAmountFee);\n            transferToken(input.recipient, actualDest, destAmount);\n        } else {\n            // fee in src amount\n            destAmount = amounts[amounts.length - 1];\n            addFeeToPlatform(input.platformWallet, src, srcAmountFee);\n        }\n    }\n\n    function validateAndPrepareSourceAmount(\n        address protocol,\n        IERC20 src,\n        uint256 srcAmount,\n        address platformWallet\n    ) internal virtual returns (uint256 actualSrcAmount) {\n        require(\n            supportedPlatformWallets[platformWallet],\n            \"unsupported platform wallet\"\n        );\n        if (src == ETH_TOKEN_ADDRESS) {\n            require(msg.value == srcAmount, \"wrong msg value\");\n            actualSrcAmount = srcAmount;\n        } else {\n            require(msg.value == 0, \"bad msg value\");\n            uint256 balanceBefore = src.balanceOf(address(this));\n            src.safeTransferFrom(msg.sender, address(this), srcAmount);\n            uint256 balanceAfter = src.balanceOf(address(this));\n            actualSrcAmount = balanceAfter.sub(balanceBefore);\n            require(actualSrcAmount > 0, \"invalid src amount\");\n\n            safeApproveAllowance(protocol, src);\n        }\n    }\n\n    function burnGasTokensAfter(uint256 gasBefore)\n        internal\n        virtual\n        returns (uint256 numGasBurns)\n    {\n        if (burnGasHelper == IBurnGasHelper(address(0))) return 0;\n        IGasToken gasToken;\n        uint256 gasAfter = gasleft();\n\n        try\n            burnGasHelper.getAmountGasTokensToBurn(\n                gasBefore.sub(gasAfter).add(msg.data.length)\n            )\n        returns (uint256 _gasBurns, address _gasToken) {\n            numGasBurns = _gasBurns;\n            gasToken = IGasToken(_gasToken);\n        } catch {\n            numGasBurns = 0;\n        }\n\n        if (numGasBurns > 0 && gasToken != IGasToken(address(0))) {\n            numGasBurns = gasToken.freeFromUpTo(msg.sender, numGasBurns);\n        }\n    }\n\n    function safeForwardTokenAndCollectFee(\n        IERC20 token,\n        address from,\n        address payable to,\n        uint256 amount,\n        uint256 platformFeeBps,\n        address payable platformWallet\n    ) internal returns (uint256 destAmount) {\n        require(platformFeeBps < BPS, \"high platform fee\");\n        require(\n            supportedPlatformWallets[platformWallet],\n            \"unsupported platform wallet\"\n        );\n        uint256 feeAmount = (amount * platformFeeBps) / BPS;\n        destAmount = amount - feeAmount;\n        if (token == ETH_TOKEN_ADDRESS) {\n            require(msg.value >= amount);\n            (bool success, ) = to.call{value: destAmount}(\"\");\n            require(success, \"transfer eth failed\");\n        } else {\n            uint256 balanceBefore = token.balanceOf(to);\n            token.safeTransferFrom(from, to, amount);\n            uint256 balanceAfter = token.balanceOf(to);\n            destAmount = balanceAfter.sub(balanceBefore);\n        }\n        addFeeToPlatform(platformWallet, token, feeAmount);\n    }\n\n    function addFeeToPlatform(\n        address wallet,\n        IERC20 token,\n        uint256 amount\n    ) internal {\n        if (amount > 0) {\n            platformWalletFees[wallet][token] = platformWalletFees[wallet][\n                token\n            ]\n                .add(amount);\n        }\n    }\n\n    function transferToken(\n        address payable recipient,\n        IERC20 token,\n        uint256 amount\n    ) internal {\n        if (amount == 0) return;\n        if (token == ETH_TOKEN_ADDRESS) {\n            (bool success, ) = recipient.call{value: amount}(\"\");\n            require(success, \"failed to transfer eth\");\n        } else {\n            token.safeTransfer(recipient, amount);\n        }\n    }\n\n    function safeApproveAllowance(address spender, IERC20 token) internal {\n        if (token.allowance(address(this), spender) == 0) {\n            getSetDecimals(token);\n            token.safeApprove(spender, MAX_ALLOWANCE);\n        }\n    }\n}\n"
    },
    "contracts/exchange/SmartWalletSwapStorage.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport \"../burnHelper/IBurnGasHelper.sol\";\nimport \"../interfaces/krystal/IKyberProxy.sol\";\nimport \"../interfaces/krystal/IGasToken.sol\";\nimport \"../interfaces/krystal/ISmartWalletLending.sol\";\nimport {\n    IERC20\n} from \"../vendor/openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {Utils} from \"../vendor/kyber/utils/Utils.sol\";\nimport {Withdrawable} from \"../vendor/kyber/utils/Withdrawable.sol\";\nimport {\n    ReentrancyGuard\n} from \"../vendor/openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport {\n    IUniswapV2Router02\n} from \"../interfaces/uniswap/IUniswapV2Router02.sol\";\n\n// solhint-disable max-states-count\n// solhint-disable private-vars-leading-underscore\ncontract SmartWalletSwapStorage is Utils, Withdrawable, ReentrancyGuard {\n    uint256 internal constant MAX_AMOUNT = type(uint256).max;\n\n    mapping(address => mapping(IERC20 => uint256)) public platformWalletFees;\n    // Proxy and routers will be set only once in constructor\n    IKyberProxy public kyberProxy;\n    // check if a router (Uniswap or its clones) is supported\n    mapping(IUniswapV2Router02 => bool) public isRouterSupported;\n\n    IBurnGasHelper public burnGasHelper;\n    mapping(address => bool) public supportedPlatformWallets;\n\n    struct TradeInput {\n        uint256 srcAmount;\n        uint256 minData; // min rate if Kyber, min return if Uni-pools\n        address payable recipient;\n        uint256 platformFeeBps;\n        address payable platformWallet;\n        bytes hint;\n    }\n\n    ISmartWalletLending public lendingImpl;\n\n    // bytes32(uint256(keccak256(\"SmartWalletSwapImplementation\")) - 1)\n    // solhint-disable max-line-length\n    bytes32 internal constant IMPLEMENTATION =\n        0x6a7efb0627ddb0e69b773958c7c9c3c9c3dc049819cdf56a8ee84c3074b2a5d7;\n\n    // solhint-disable no-empty-blocks\n    constructor(address _admin) Withdrawable(_admin) {}\n}\n"
    },
    "contracts/interfaces/krystal/IKyberProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    IERC20\n} from \"../../vendor/openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ninterface IKyberProxy {\n    function tradeWithHintAndFee(\n        IERC20 src,\n        uint256 srcAmount,\n        IERC20 dest,\n        address payable destAddress,\n        uint256 maxDestAmount,\n        uint256 minConversionRate,\n        address payable platformWallet,\n        uint256 platformFeeBps,\n        bytes calldata hint\n    ) external payable returns (uint256 destAmount);\n\n    function getExpectedRateAfterFee(\n        IERC20 src,\n        IERC20 dest,\n        uint256 srcQty,\n        uint256 platformFeeBps,\n        bytes calldata hint\n    ) external view returns (uint256 expectedRate);\n}\n"
    },
    "contracts/interfaces/krystal/IGasToken.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\ninterface IGasToken {\n    function mint(uint256 value) external;\n\n    function freeUpTo(uint256 value) external returns (uint256 freed);\n\n    function freeFromUpTo(address from, uint256 value)\n        external\n        returns (uint256 freed);\n\n    function balanceOf(address who) external view returns (uint256);\n\n    function transfer(address to, uint256 value)\n        external\n        returns (bool success);\n\n    function transferFrom(\n        address from,\n        address to,\n        uint256 value\n    ) external returns (bool success);\n\n    function approve(address spender, uint256 value)\n        external\n        returns (bool success);\n}\n"
    },
    "contracts/exchange/SmartWalletSwapProxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity 0.8.0;\n\nimport {\n    Address\n} from \"../vendor/openzeppelin/contracts/utils/Address.sol\";\nimport \"./SmartWalletSwapStorage.sol\";\n\ncontract SmartWalletSwapProxy is SmartWalletSwapStorage {\n    using Address for address;\n\n    event ImplementationUpdated(address indexed implementation);\n\n    constructor(\n        address _admin,\n        address _implementation,\n        IKyberProxy _proxy,\n        IUniswapV2Router02[] memory _routers\n    ) SmartWalletSwapStorage(_admin) {\n        _setImplementation(_implementation);\n        kyberProxy = _proxy;\n        for (uint256 i = 0; i < _routers.length; i++) {\n            isRouterSupported[_routers[i]] = true;\n        }\n    }\n\n    function updateNewImplementation(address _implementation)\n        external\n        onlyAdmin\n    {\n        _setImplementation(_implementation);\n        emit ImplementationUpdated(_implementation);\n    }\n\n    // solhint-disable-next-line no-empty-blocks\n    receive() external payable {}\n\n    /**\n     * @dev Delegates execution to an implementation contract.\n     * It returns to the external caller whatever the implementation returns\n     * or forwards reverts.\n     */\n    // solhint-disable no-complex-fallback\n    fallback() external payable {\n        (bool success, ) = implementation().delegatecall(msg.data);\n\n        assembly {\n            let free_mem_ptr := mload(0x40)\n            returndatacopy(free_mem_ptr, 0, returndatasize())\n            switch success\n                case 0 {\n                    revert(free_mem_ptr, returndatasize())\n                }\n                default {\n                    return(free_mem_ptr, returndatasize())\n                }\n        }\n    }\n\n    function implementation() public view returns (address impl) {\n        bytes32 slot = IMPLEMENTATION;\n        assembly {\n            impl := sload(slot)\n        }\n    }\n\n    function _setImplementation(address _implementation) internal {\n        require(_implementation.isContract(), \"non-contract address\");\n\n        bytes32 slot = IMPLEMENTATION;\n        assembly {\n            sstore(slot, _implementation)\n        }\n    }\n}\n"
    },
    "contracts/vendor/openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\nimport \"../GSN/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        address msgSender = _msgSender();\n        _owner = msgSender;\n        emit OwnershipTransferred(address(0), msgSender);\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        require(_owner == _msgSender(), \"Ownable: caller is not the owner\");\n        _;\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        emit OwnershipTransferred(_owner, address(0));\n        _owner = address(0);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(\n            newOwner != address(0),\n            \"Ownable: new owner is the zero address\"\n        );\n        emit OwnershipTransferred(_owner, newOwner);\n        _owner = newOwner;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}