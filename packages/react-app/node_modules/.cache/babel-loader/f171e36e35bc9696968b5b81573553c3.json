{"ast":null,"code":"import { ethers } from \"ethers\";\nimport { getMiniAddress } from \"../utils/helpers\";\nimport { addresses, abis } from \"@project/contracts\";\nimport { GelatoCore } from \"@gelatonetwork/core\";\nconst {\n  INSTA_LIST_ADDR,\n  GELATO_CORE,\n  MAKER_RESOLVER_ADDR\n} = addresses;\nconst {\n  InstaList,\n  MakerResolver\n} = abis;\nexport const getUserAddress = async provider => {\n  const signer = await provider.getSigner();\n  return await signer.getAddress();\n};\nexport const getMiniUserAddress = async provider => {\n  return getMiniAddress(await getUserAddress(provider));\n};\nexport const getUserProxy = async user => {\n  const signer = await user.getSigner();\n  const userAddr = await signer.getAddress();\n  const instaListContract = new ethers.Contract(INSTA_LIST_ADDR, InstaList, signer);\n  return await instaListContract.accountAddr((await instaListContract.userLink(userAddr)).first);\n};\nexport const getUserProxyContract = async user => {\n  const signer = await user.getSigner();\n  const userProxyAddr = await getUserProxy(user);\n  return new ethers.Contract(userProxyAddr, [\"function cast(address[] _targets, bytes[] _datas, address _origin) payable\", \"function isAuth(address user) view returns (bool)\"], signer);\n};\nexport const getGelatoGasPrice = async provider => {\n  const gelatoCoreContract = new ethers.Contract(GELATO_CORE, GelatoCore.abi, provider);\n  const oracleAbi = [\"function latestAnswer() view returns (int256)\"];\n  const gelatoGasPriceOracleAddress = await gelatoCoreContract.gelatoGasPriceOracle(); // Get gelatoGasPriceOracleAddress\n\n  const gelatoGasPriceOracle = new ethers.Contract(gelatoGasPriceOracleAddress, oracleAbi, provider); // lastAnswer is used by GelatoGasPriceOracle as well as the Chainlink Oracle\n\n  return await gelatoGasPriceOracle.latestAnswer();\n};\nexport const getTokenBalance = async (userAccount, token) => {\n  const tokenContract = new ethers.Contract(token, [\"function balanceOf(address) view returns (uint256)\"], userAccount);\n  const userBalance = await tokenContract.balanceOf(userAccount);\n  return userBalance;\n};\nexport const getTokenBalanceString = async (userAccount, token, tokenSymbol, decimals) => {\n  const userBalance = await getTokenBalance(userAccount, token);\n  const userBalanceHumanReadable = ethers.utils.formatUnits(userBalance, decimals);\n  return `${parseFloat(userBalanceHumanReadable).toFixed(8)} ${tokenSymbol}`;\n};\nexport const getETHAVaultDebt = async (user, userAddr) => {\n  const vault = await getVault(user, userAddr, \"ETH-A\");\n  if (vault === undefined) return 0;\n  return vault.debt;\n};\nexport const getETHAVaultCols = async (user, userAddr) => {\n  const vault = await getVault(user, userAddr, \"ETH-A\");\n  if (vault === undefined) return 0;\n  console.log(vault);\n  return vault.collateral;\n};\nexport const getETHBVaultDebt = async (user, userAddr) => {\n  const vault = await getVault(user, userAddr, \"ETH-B\");\n  if (vault === undefined) return 0;\n  return vault.debt;\n};\nexport const getETHBVaultCols = async (user, userAddr) => {\n  const vault = await getVault(user, userAddr, \"ETH-B\");\n  if (vault === undefined) return 0;\n  return vault.collateral;\n};\nexport const gelatoIsAuth = async user => {\n  const userProxyContract = await getUserProxyContract(user);\n  return userProxyContract.isAuth(GELATO_CORE);\n};\nexport const userHaveETHAVault = async (user, userAddr) => {\n  return (await getVault(user, userAddr, \"ETH-A\")) !== undefined;\n};\nexport const userHaveETHBVault = async (user, userAddr) => {\n  return (await getVault(user, userAddr, \"ETH-B\")) !== undefined;\n};\nexport const getVault = async (user, userAddr, colType) => {\n  const signer = await user.getSigner();\n  const makerResolverContract = new ethers.Contract(MAKER_RESOLVER_ADDR, MakerResolver, signer);\n  let vaults = await makerResolverContract.getVaults(userAddr);\n\n  for (let i = 0; i < vaults.length; i++) {\n    if (vaults[i].colType === colType) {\n      return vaults[i];\n    }\n  }\n\n  return undefined;\n};","map":{"version":3,"sources":["/Users/Hilmar/code/integrations/krystal/gelato-krystal/packages/react-app/src/services/stateReads.js"],"names":["ethers","getMiniAddress","addresses","abis","GelatoCore","INSTA_LIST_ADDR","GELATO_CORE","MAKER_RESOLVER_ADDR","InstaList","MakerResolver","getUserAddress","provider","signer","getSigner","getAddress","getMiniUserAddress","getUserProxy","user","userAddr","instaListContract","Contract","accountAddr","userLink","first","getUserProxyContract","userProxyAddr","getGelatoGasPrice","gelatoCoreContract","abi","oracleAbi","gelatoGasPriceOracleAddress","gelatoGasPriceOracle","latestAnswer","getTokenBalance","userAccount","token","tokenContract","userBalance","balanceOf","getTokenBalanceString","tokenSymbol","decimals","userBalanceHumanReadable","utils","formatUnits","parseFloat","toFixed","getETHAVaultDebt","vault","getVault","undefined","debt","getETHAVaultCols","console","log","collateral","getETHBVaultDebt","getETHBVaultCols","gelatoIsAuth","userProxyContract","isAuth","userHaveETHAVault","userHaveETHBVault","colType","makerResolverContract","vaults","getVaults","i","length"],"mappings":"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","sourcesContent":["import { ethers } from \"ethers\";\nimport { getMiniAddress } from \"../utils/helpers\";\nimport { addresses, abis } from \"@project/contracts\";\nimport { GelatoCore } from \"@gelatonetwork/core\";\n\nconst { INSTA_LIST_ADDR, GELATO_CORE, MAKER_RESOLVER_ADDR } = addresses;\nconst { InstaList, MakerResolver } = abis;\n\nexport const getUserAddress = async (provider) => {\n  const signer = await provider.getSigner();\n  return await signer.getAddress();\n};\n\nexport const getMiniUserAddress = async (provider) => {\n  return getMiniAddress(await getUserAddress(provider));\n};\n\nexport const getUserProxy = async (user) => {\n  const signer = await user.getSigner();\n  const userAddr = await signer.getAddress();\n  const instaListContract = new ethers.Contract(\n    INSTA_LIST_ADDR,\n    InstaList,\n    signer\n  );\n  return await instaListContract.accountAddr(\n    (await instaListContract.userLink(userAddr)).first\n  );\n};\n\nexport const getUserProxyContract = async (user) => {\n  const signer = await user.getSigner();\n  const userProxyAddr = await getUserProxy(user);\n  return new ethers.Contract(\n    userProxyAddr,\n    [\n      \"function cast(address[] _targets, bytes[] _datas, address _origin) payable\",\n      \"function isAuth(address user) view returns (bool)\",\n    ],\n    signer\n  );\n};\n\nexport const getGelatoGasPrice = async (provider) => {\n  const gelatoCoreContract = new ethers.Contract(\n    GELATO_CORE,\n    GelatoCore.abi,\n    provider\n  );\n\n  const oracleAbi = [\"function latestAnswer() view returns (int256)\"];\n\n  const gelatoGasPriceOracleAddress = await gelatoCoreContract.gelatoGasPriceOracle();\n\n  // Get gelatoGasPriceOracleAddress\n  const gelatoGasPriceOracle = new ethers.Contract(\n    gelatoGasPriceOracleAddress,\n    oracleAbi,\n    provider\n  );\n\n  // lastAnswer is used by GelatoGasPriceOracle as well as the Chainlink Oracle\n  return await gelatoGasPriceOracle.latestAnswer();\n};\n\nexport const getTokenBalance = async (userAccount, token) => {\n  const tokenContract = new ethers.Contract(\n    token,\n    [\"function balanceOf(address) view returns (uint256)\"],\n    userAccount\n  );\n  const userBalance = await tokenContract.balanceOf(userAccount);\n  return userBalance;\n};\n\nexport const getTokenBalanceString = async (\n  userAccount,\n  token,\n  tokenSymbol,\n  decimals\n) => {\n  const userBalance = await getTokenBalance(userAccount, token);\n  const userBalanceHumanReadable = ethers.utils.formatUnits(\n    userBalance,\n    decimals\n  );\n  return `${parseFloat(userBalanceHumanReadable).toFixed(8)} ${tokenSymbol}`;\n};\n\nexport const getETHAVaultDebt = async (user, userAddr) => {\n  const vault = await getVault(user, userAddr, \"ETH-A\");\n  if (vault === undefined) return 0;\n  return vault.debt;\n};\n\nexport const getETHAVaultCols = async (user, userAddr) => {\n  const vault = await getVault(user, userAddr, \"ETH-A\");\n  if (vault === undefined) return 0;\n  console.log(vault);\n  return vault.collateral;\n};\n\nexport const getETHBVaultDebt = async (user, userAddr) => {\n  const vault = await getVault(user, userAddr, \"ETH-B\");\n  if (vault === undefined) return 0;\n  return vault.debt;\n};\n\nexport const getETHBVaultCols = async (user, userAddr) => {\n  const vault = await getVault(user, userAddr, \"ETH-B\");\n  if (vault === undefined) return 0;\n  return vault.collateral;\n};\n\nexport const gelatoIsAuth = async (user) => {\n  const userProxyContract = await getUserProxyContract(user);\n  return userProxyContract.isAuth(GELATO_CORE);\n};\n\nexport const userHaveETHAVault = async (user, userAddr) => {\n  return (await getVault(user, userAddr, \"ETH-A\")) !== undefined;\n};\n\nexport const userHaveETHBVault = async (user, userAddr) => {\n  return (await getVault(user, userAddr, \"ETH-B\")) !== undefined;\n};\n\nexport const getVault = async (user, userAddr, colType) => {\n  const signer = await user.getSigner();\n  const makerResolverContract = new ethers.Contract(\n    MAKER_RESOLVER_ADDR,\n    MakerResolver,\n    signer\n  );\n\n  let vaults = await makerResolverContract.getVaults(userAddr);\n  for (let i = 0; i < vaults.length; i++) {\n    if (vaults[i].colType === colType) {\n      return vaults[i];\n    }\n  }\n  return undefined;\n};\n"]},"metadata":{},"sourceType":"module"}