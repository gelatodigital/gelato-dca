{"ast":null,"code":"import { ethers } from \"ethers\";\nimport { getMiniAddress } from \"../utils/helpers\";\nimport { addresses, abis } from \"@gelato-krystal/contracts\";\nimport { GelatoCore } from \"@gelatonetwork/core\";\nconst {\n  INSTA_LIST_ADDR,\n  GELATO_CORE,\n  MAKER_RESOLVER_ADDR,\n  GELATO_KRYSTAL\n} = addresses;\nconst {\n  InstaList,\n  MakerResolver,\n  GelatoKrystalAbi\n} = abis;\nexport const getUserAddress = async provider => {\n  const signer = await provider.getSigner();\n  return await signer.getAddress();\n};\nexport const getMiniUserAddress = async provider => {\n  return getMiniAddress(await getUserAddress(provider));\n};\nexport const getUserProxy = async user => {\n  const signer = await user.getSigner();\n  const userAddr = await signer.getAddress();\n  const instaListContract = new ethers.Contract(INSTA_LIST_ADDR, InstaList, signer);\n  return await instaListContract.accountAddr((await instaListContract.userLink(userAddr)).first);\n};\nexport const getUserProxyContract = async user => {\n  const signer = await user.getSigner();\n  const userProxyAddr = await getUserProxy(user);\n  return new ethers.Contract(userProxyAddr, [\"function cast(address[] _targets, bytes[] _datas, address _origin) payable\", \"function isAuth(address user) view returns (bool)\"], signer);\n};\nexport const getGelatoKrystal = async user => {\n  const signer = await user.getSigner();\n  return new ethers.Contract(GELATO_KRYSTAL, GelatoKrystalAbi, signer);\n};\nexport const getGelatoGasPrice = async provider => {\n  const gelatoCoreContract = new ethers.Contract(GELATO_CORE, GelatoCore.abi, provider);\n  const oracleAbi = [\"function latestAnswer() view returns (int256)\"];\n  const gelatoGasPriceOracleAddress = await gelatoCoreContract.gelatoGasPriceOracle(); // Get gelatoGasPriceOracleAddress\n\n  const gelatoGasPriceOracle = new ethers.Contract(gelatoGasPriceOracleAddress, oracleAbi, provider); // lastAnswer is used by GelatoGasPriceOracle as well as the Chainlink Oracle\n\n  return await gelatoGasPriceOracle.latestAnswer();\n};\nexport const getTokenBalance = async (user, token) => {\n  const signer = await user.getSigner();\n  const userAddr = await signer.getAddress();\n  const tokenContract = new ethers.Contract(token, [\"function balanceOf(address) view returns (uint256)\"], signer);\n  const userBalance = await tokenContract.balanceOf(userAddr);\n  return userBalance;\n};\nexport const getTokenBalanceString = async (userAccount, token, tokenSymbol, decimals) => {\n  const userBalance = await getTokenBalance(userAccount, token);\n  const userBalanceHumanReadable = ethers.utils.formatUnits(userBalance, decimals);\n  return `${parseFloat(userBalanceHumanReadable).toFixed(8)} ${tokenSymbol}`;\n};\nexport const getETHAVaultDebt = async (user, userAddr) => {\n  const vault = await getVault(user, userAddr, \"ETH-A\");\n  if (vault === undefined) return 0;\n  return vault.debt;\n};\nexport const getETHAVaultCols = async (user, userAddr) => {\n  const vault = await getVault(user, userAddr, \"ETH-A\");\n  if (vault === undefined) return 0;\n  console.log(vault);\n  return vault.collateral;\n};\nexport const getETHBVaultDebt = async (user, userAddr) => {\n  const vault = await getVault(user, userAddr, \"ETH-B\");\n  if (vault === undefined) return 0;\n  return vault.debt;\n};\nexport const getETHBVaultCols = async (user, userAddr) => {\n  const vault = await getVault(user, userAddr, \"ETH-B\");\n  if (vault === undefined) return 0;\n  return vault.collateral;\n};\nexport const gelatoIsAuth = async user => {\n  const userProxyContract = await getUserProxyContract(user);\n  return userProxyContract.isAuth(GELATO_CORE);\n};\nexport const userHaveETHAVault = async (user, userAddr) => {\n  return (await getVault(user, userAddr, \"ETH-A\")) !== undefined;\n};\nexport const userHaveETHBVault = async (user, userAddr) => {\n  return (await getVault(user, userAddr, \"ETH-B\")) !== undefined;\n};\nexport const getVault = async (user, userAddr, colType) => {\n  const signer = await user.getSigner();\n  const makerResolverContract = new ethers.Contract(MAKER_RESOLVER_ADDR, MakerResolver, signer);\n  let vaults = await makerResolverContract.getVaults(userAddr);\n\n  for (let i = 0; i < vaults.length; i++) {\n    if (vaults[i].colType === colType) {\n      return vaults[i];\n    }\n  }\n\n  return undefined;\n};","map":{"version":3,"sources":["/Users/Hilmar/code/integrations/krystal/gelato-krystal/packages/react-app/src/services/stateReads.js"],"names":["ethers","getMiniAddress","addresses","abis","GelatoCore","INSTA_LIST_ADDR","GELATO_CORE","MAKER_RESOLVER_ADDR","GELATO_KRYSTAL","InstaList","MakerResolver","GelatoKrystalAbi","getUserAddress","provider","signer","getSigner","getAddress","getMiniUserAddress","getUserProxy","user","userAddr","instaListContract","Contract","accountAddr","userLink","first","getUserProxyContract","userProxyAddr","getGelatoKrystal","getGelatoGasPrice","gelatoCoreContract","abi","oracleAbi","gelatoGasPriceOracleAddress","gelatoGasPriceOracle","latestAnswer","getTokenBalance","token","tokenContract","userBalance","balanceOf","getTokenBalanceString","userAccount","tokenSymbol","decimals","userBalanceHumanReadable","utils","formatUnits","parseFloat","toFixed","getETHAVaultDebt","vault","getVault","undefined","debt","getETHAVaultCols","console","log","collateral","getETHBVaultDebt","getETHBVaultCols","gelatoIsAuth","userProxyContract","isAuth","userHaveETHAVault","userHaveETHBVault","colType","makerResolverContract","vaults","getVaults","i","length"],"mappings":"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","sourcesContent":["import { ethers } from \"ethers\";\nimport { getMiniAddress } from \"../utils/helpers\";\nimport { addresses, abis } from \"@gelato-krystal/contracts\";\nimport { GelatoCore } from \"@gelatonetwork/core\";\n\nconst {\n  INSTA_LIST_ADDR,\n  GELATO_CORE,\n  MAKER_RESOLVER_ADDR,\n  GELATO_KRYSTAL,\n} = addresses;\nconst { InstaList, MakerResolver, GelatoKrystalAbi } = abis;\n\nexport const getUserAddress = async (provider) => {\n  const signer = await provider.getSigner();\n  return await signer.getAddress();\n};\n\nexport const getMiniUserAddress = async (provider) => {\n  return getMiniAddress(await getUserAddress(provider));\n};\n\nexport const getUserProxy = async (user) => {\n  const signer = await user.getSigner();\n  const userAddr = await signer.getAddress();\n  const instaListContract = new ethers.Contract(\n    INSTA_LIST_ADDR,\n    InstaList,\n    signer\n  );\n  return await instaListContract.accountAddr(\n    (await instaListContract.userLink(userAddr)).first\n  );\n};\n\nexport const getUserProxyContract = async (user) => {\n  const signer = await user.getSigner();\n  const userProxyAddr = await getUserProxy(user);\n  return new ethers.Contract(\n    userProxyAddr,\n    [\n      \"function cast(address[] _targets, bytes[] _datas, address _origin) payable\",\n      \"function isAuth(address user) view returns (bool)\",\n    ],\n    signer\n  );\n};\n\nexport const getGelatoKrystal = async (user) => {\n  const signer = await user.getSigner();\n  return new ethers.Contract(GELATO_KRYSTAL, GelatoKrystalAbi, signer);\n};\n\nexport const getGelatoGasPrice = async (provider) => {\n  const gelatoCoreContract = new ethers.Contract(\n    GELATO_CORE,\n    GelatoCore.abi,\n    provider\n  );\n\n  const oracleAbi = [\"function latestAnswer() view returns (int256)\"];\n\n  const gelatoGasPriceOracleAddress = await gelatoCoreContract.gelatoGasPriceOracle();\n\n  // Get gelatoGasPriceOracleAddress\n  const gelatoGasPriceOracle = new ethers.Contract(\n    gelatoGasPriceOracleAddress,\n    oracleAbi,\n    provider\n  );\n\n  // lastAnswer is used by GelatoGasPriceOracle as well as the Chainlink Oracle\n  return await gelatoGasPriceOracle.latestAnswer();\n};\n\nexport const getTokenBalance = async (user, token) => {\n  const signer = await user.getSigner();\n  const userAddr = await signer.getAddress();\n\n  const tokenContract = new ethers.Contract(\n    token,\n    [\"function balanceOf(address) view returns (uint256)\"],\n    signer\n  );\n  const userBalance = await tokenContract.balanceOf(userAddr);\n  return userBalance;\n};\n\nexport const getTokenBalanceString = async (\n  userAccount,\n  token,\n  tokenSymbol,\n  decimals\n) => {\n  const userBalance = await getTokenBalance(userAccount, token);\n  const userBalanceHumanReadable = ethers.utils.formatUnits(\n    userBalance,\n    decimals\n  );\n  return `${parseFloat(userBalanceHumanReadable).toFixed(8)} ${tokenSymbol}`;\n};\n\nexport const getETHAVaultDebt = async (user, userAddr) => {\n  const vault = await getVault(user, userAddr, \"ETH-A\");\n  if (vault === undefined) return 0;\n  return vault.debt;\n};\n\nexport const getETHAVaultCols = async (user, userAddr) => {\n  const vault = await getVault(user, userAddr, \"ETH-A\");\n  if (vault === undefined) return 0;\n  console.log(vault);\n  return vault.collateral;\n};\n\nexport const getETHBVaultDebt = async (user, userAddr) => {\n  const vault = await getVault(user, userAddr, \"ETH-B\");\n  if (vault === undefined) return 0;\n  return vault.debt;\n};\n\nexport const getETHBVaultCols = async (user, userAddr) => {\n  const vault = await getVault(user, userAddr, \"ETH-B\");\n  if (vault === undefined) return 0;\n  return vault.collateral;\n};\n\nexport const gelatoIsAuth = async (user) => {\n  const userProxyContract = await getUserProxyContract(user);\n  return userProxyContract.isAuth(GELATO_CORE);\n};\n\nexport const userHaveETHAVault = async (user, userAddr) => {\n  return (await getVault(user, userAddr, \"ETH-A\")) !== undefined;\n};\n\nexport const userHaveETHBVault = async (user, userAddr) => {\n  return (await getVault(user, userAddr, \"ETH-B\")) !== undefined;\n};\n\nexport const getVault = async (user, userAddr, colType) => {\n  const signer = await user.getSigner();\n  const makerResolverContract = new ethers.Contract(\n    MAKER_RESOLVER_ADDR,\n    MakerResolver,\n    signer\n  );\n\n  let vaults = await makerResolverContract.getVaults(userAddr);\n  for (let i = 0; i < vaults.length; i++) {\n    if (vaults[i].colType === colType) {\n      return vaults[i];\n    }\n  }\n  return undefined;\n};\n"]},"metadata":{},"sourceType":"module"}