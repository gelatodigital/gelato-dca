{"ast":null,"code":"import { ethers } from \"ethers\";\nimport { addresses, abis } from \"@gelato-krystal/contracts\";\nimport { abiEncodeWithSelector } from \"../utils/helpers\";\nimport { Operation, Condition, Action, Task } from \"@gelatonetwork/core\";\nimport { PRICE_ORACLE_MAKER_PAYLOAD, ETH } from \"../utils/constants\";\nimport { getUserProxyContract } from \"./stateReads\";\n\nconst GelatoCoreLib = require(\"@gelatonetwork/core\");\n\nconst {\n  EXTERNAL_PROVIDER_ADDR,\n  PRICE_ORACLE_ADDR,\n  CONDITION_VAULT_IS_SAFE_ADDR,\n  CONDITION_DEBT_VAULT_WILL_BE_SAFE,\n  CONDITION_DEBT_BRIDGE_AFFORDABLE_ADDR,\n  CONNECT_FULL_REFINANCE_ADDR,\n  PROVIDER_DSA_MODULE_ADDR,\n  CONDITION_BORROW_AMOUNT_IS_DUST,\n  CONDITION_DEBT_CEILING_IS_REACHED,\n  GELATO_CORE\n} = addresses;\nconst {\n  ConnectGelato\n} = abis;\nexport const openMakerVault = async colType => {\n  return await abiEncodeWithSelector({\n    abi: [\"function open(string colType) payable returns (uint)\"],\n    functionname: \"open\",\n    inputs: [colType]\n  });\n};\nexport const depositMakerVault = async (value, vaultId) => {\n  return await abiEncodeWithSelector({\n    abi: [\"function deposit(uint vault, uint amt, uint getId, uint setId) payable\"],\n    functionname: \"deposit\",\n    inputs: [vaultId, value, 0, 0]\n  });\n};\nexport const borrowMakerVault = async (value, vaultId) => {\n  return await abiEncodeWithSelector({\n    abi: [\"function borrow(uint vault, uint amt, uint getId, uint setId) payable\"],\n    functionname: \"borrow\",\n    inputs: [vaultId, value, 0, 0]\n  });\n};\nexport const authorizeGelato = async () => {\n  return await abiEncodeWithSelector({\n    abi: [\"function add(address authority) payable \"],\n    functionname: \"add\",\n    inputs: [GELATO_CORE]\n  });\n};\nexport const submitRefinanceMakerToMaker = async (user, ratioLimit, minColRatio, vaultAId, vaultBId) => {\n  const userProxy = await getUserProxyContract(user); //#region Condition Vault is Safe\n\n  const conditionMakerVaultUnsafeObj = new Condition({\n    inst: CONDITION_VAULT_IS_SAFE_ADDR,\n    data: await abiEncodeWithSelector({\n      abi: [\"function isVaultUnsafe(uint256 _vaultId, address _priceOracle, bytes _oraclePayload, uint256 _minColRatio) view returns (string)\"],\n      functionname: \"isVaultUnsafe\",\n      inputs: [vaultAId, PRICE_ORACLE_ADDR, PRICE_ORACLE_MAKER_PAYLOAD, minColRatio]\n    })\n  }); //#endregion Condition Vault is Safe\n  //#region Condition Borrow Amount is dust\n\n  const conditionBorrowAmtIsDust = new Condition({\n    inst: CONDITION_BORROW_AMOUNT_IS_DUST,\n    data: await abiEncodeWithSelector({\n      abi: [\"function isBorrowAmountDust(address _dsa, uint256 _fromVaultId, uint256 _destVaultId, string memory _destColType) view returns (string)\"],\n      functionname: \"isBorrowAmountDust\",\n      inputs: [userProxy.address, vaultAId, vaultBId, \"ETH-B\"]\n    })\n  }); //#endregion Condition Borrow Amount is dust\n  //#region Condition Borrow Amount is dust\n\n  const conditionDebtCeilingIsReached = new Condition({\n    inst: CONDITION_DEBT_CEILING_IS_REACHED,\n    data: await abiEncodeWithSelector({\n      abi: [\"function isDebtCeilingReached(address _dsa, uint256 _fromVaultId, uint256 _destVaultId, string memory _destColType) view returns (string)\"],\n      functionname: \"isDebtCeilingReached\",\n      inputs: [userProxy.address, vaultAId, vaultBId, \"ETH-B\"]\n    })\n  }); //#endregion Condition Borrow Amount is dust\n  //#region Condition Debt Bridge is Affordable\n\n  const conditionDebtBridgeIsAffordableObj = new Condition({\n    inst: CONDITION_DEBT_BRIDGE_AFFORDABLE_ADDR,\n    data: await abiEncodeWithSelector({\n      abi: [\"function isAffordable(uint256 _vaultId, uint256 _ratioLimit) view returns (string)\"],\n      functionname: \"isAffordable\",\n      inputs: [vaultAId, ratioLimit]\n    })\n  }); //#endregion Condition Debt Bridge is Affordable\n  //#region Condition is Vault B Will be Safe\n\n  const conditionIsDestVaultWillBeSafeObj = new Condition({\n    inst: CONDITION_DEBT_VAULT_WILL_BE_SAFE,\n    data: await abiEncodeWithSelector({\n      abi: [\"function destVaultWillBeSafe(address _dsa, uint256 _fromVaultId, uint256 _destVaultId, string memory _destColType) view returns (string)\"],\n      functionname: \"destVaultWillBeSafe\",\n      inputs: [userProxy.address, vaultAId, vaultBId, \"ETH-B\"]\n    })\n  }); //#endregion Condition is Vault B Will be Safe\n  //#region Action Call Connector For Full Refinancing\n\n  const debtBridgeCalculationForFullRefinanceAction = new Action({\n    addr: CONNECT_FULL_REFINANCE_ADDR,\n    data: await abiEncodeWithSelector({\n      abi: [\"function getDataAndCastMakerToMaker(uint256 _vaultAId, uint256 _vaultBId, address _colToken, string _colType) payable\"],\n      functionname: \"getDataAndCastMakerToMaker\",\n      inputs: [vaultAId, vaultBId, ETH, \"ETH-B\"]\n    }),\n    operation: Operation.Delegatecall,\n    termsOkCheck: true\n  }); //#endregion Action Call Connector For Full Refinancing\n  //#region Debt Bridge Task Creation\n\n  const debtBridgeTask = new Task({\n    conditions: [conditionMakerVaultUnsafeObj, conditionDebtBridgeIsAffordableObj, conditionIsDestVaultWillBeSafeObj, conditionBorrowAmtIsDust, conditionDebtCeilingIsReached],\n    actions: [debtBridgeCalculationForFullRefinanceAction]\n  });\n  getTaskHash(debtBridgeTask); //#endregion Debt Bridge Task Creation\n  //#region Gelato Connector call cast\n\n  const gelatoExternalProvider = new GelatoCoreLib.GelatoProvider({\n    addr: EXTERNAL_PROVIDER_ADDR,\n    // Gelato Provider Address\n    module: PROVIDER_DSA_MODULE_ADDR // Gelato DSA module\n\n  });\n  return await abiEncodeWithSelector({\n    abi: ConnectGelato,\n    functionname: \"submitTask\",\n    inputs: [gelatoExternalProvider, debtBridgeTask, 0]\n  }); //#endregion Gelato Connector call cast\n};\nexport const getTaskHash = task => {\n  const conditionsWithoutData = [];\n\n  for (let condition of task.conditions) {\n    conditionsWithoutData.push(condition.inst);\n  }\n\n  const actionsWithoutData = [];\n\n  for (let action of task.actions) {\n    actionsWithoutData.push({\n      addr: action.addr,\n      operation: parseInt(action.operation),\n      dataFlow: parseInt(action.dataFlow),\n      value: parseInt(action.value) === 0 ? false : true,\n      termsOkCheck: action.termsOkCheck\n    });\n  }\n\n  const encodedData = ethers.utils.defaultAbiCoder.encode([\"address[] conditionAddresses\", \"tuple(address addr, uint8 operation, uint8 dataFlow, bool value, bool termsOkCheck)[] noDataActions\"], [conditionsWithoutData, actionsWithoutData]);\n  const taskIdentifier = ethers.utils.keccak256(encodedData);\n  console.log(taskIdentifier);\n  return taskIdentifier;\n};\nexport const getCancelTaskData = async taskReceipt => {\n  const iGelatoHandler = new ethers.utils.Interface([\"function multiCancelTasks(tuple(uint256 id, address userProxy, tuple(address addr, address module) provider, uint256 index, tuple(tuple(address inst, bytes data)[] conditions, tuple(address addr, bytes data, uint8 operation, uint8 dataFlow, uint256 value, bool termsOkCheck)[] actions, uint256 selfProviderGasLimit, uint256 selfProviderGasPriceCeil)[] tasks, uint256 expiryDate, uint256 cycleId, uint256 submissionsLeft)[] _TasksToCancel)\"]);\n  return iGelatoHandler.encodeFunctionData(\"multiCancelTasks\", [[taskReceipt]]); // array of taskReceipts\n};","map":{"version":3,"sources":["/Users/Hilmar/code/integrations/krystal/gelato-krystal/packages/react-app/src/services/payloadGeneration.js"],"names":["ethers","addresses","abis","abiEncodeWithSelector","Operation","Condition","Action","Task","PRICE_ORACLE_MAKER_PAYLOAD","ETH","getUserProxyContract","GelatoCoreLib","require","EXTERNAL_PROVIDER_ADDR","PRICE_ORACLE_ADDR","CONDITION_VAULT_IS_SAFE_ADDR","CONDITION_DEBT_VAULT_WILL_BE_SAFE","CONDITION_DEBT_BRIDGE_AFFORDABLE_ADDR","CONNECT_FULL_REFINANCE_ADDR","PROVIDER_DSA_MODULE_ADDR","CONDITION_BORROW_AMOUNT_IS_DUST","CONDITION_DEBT_CEILING_IS_REACHED","GELATO_CORE","ConnectGelato","openMakerVault","colType","abi","functionname","inputs","depositMakerVault","value","vaultId","borrowMakerVault","authorizeGelato","submitRefinanceMakerToMaker","user","ratioLimit","minColRatio","vaultAId","vaultBId","userProxy","conditionMakerVaultUnsafeObj","inst","data","conditionBorrowAmtIsDust","address","conditionDebtCeilingIsReached","conditionDebtBridgeIsAffordableObj","conditionIsDestVaultWillBeSafeObj","debtBridgeCalculationForFullRefinanceAction","addr","operation","Delegatecall","termsOkCheck","debtBridgeTask","conditions","actions","getTaskHash","gelatoExternalProvider","GelatoProvider","module","task","conditionsWithoutData","condition","push","actionsWithoutData","action","parseInt","dataFlow","encodedData","utils","defaultAbiCoder","encode","taskIdentifier","keccak256","console","log","getCancelTaskData","taskReceipt","iGelatoHandler","Interface","encodeFunctionData"],"mappings":"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","sourcesContent":["import { ethers } from \"ethers\";\nimport { addresses, abis } from \"@gelato-krystal/contracts\";\nimport { abiEncodeWithSelector } from \"../utils/helpers\";\nimport { Operation, Condition, Action, Task } from \"@gelatonetwork/core\";\nimport { PRICE_ORACLE_MAKER_PAYLOAD, ETH } from \"../utils/constants\";\nimport { getUserProxyContract } from \"./stateReads\";\nconst GelatoCoreLib = require(\"@gelatonetwork/core\");\nconst {\n  EXTERNAL_PROVIDER_ADDR,\n  PRICE_ORACLE_ADDR,\n  CONDITION_VAULT_IS_SAFE_ADDR,\n  CONDITION_DEBT_VAULT_WILL_BE_SAFE,\n  CONDITION_DEBT_BRIDGE_AFFORDABLE_ADDR,\n  CONNECT_FULL_REFINANCE_ADDR,\n  PROVIDER_DSA_MODULE_ADDR,\n  CONDITION_BORROW_AMOUNT_IS_DUST,\n  CONDITION_DEBT_CEILING_IS_REACHED,\n  GELATO_CORE,\n} = addresses;\n\nconst { ConnectGelato } = abis;\n\nexport const openMakerVault = async (colType) => {\n  return await abiEncodeWithSelector({\n    abi: [\"function open(string colType) payable returns (uint)\"],\n    functionname: \"open\",\n    inputs: [colType],\n  });\n};\n\nexport const depositMakerVault = async (value, vaultId) => {\n  return await abiEncodeWithSelector({\n    abi: [\n      \"function deposit(uint vault, uint amt, uint getId, uint setId) payable\",\n    ],\n    functionname: \"deposit\",\n    inputs: [vaultId, value, 0, 0],\n  });\n};\n\nexport const borrowMakerVault = async (value, vaultId) => {\n  return await abiEncodeWithSelector({\n    abi: [\n      \"function borrow(uint vault, uint amt, uint getId, uint setId) payable\",\n    ],\n    functionname: \"borrow\",\n    inputs: [vaultId, value, 0, 0],\n  });\n};\n\nexport const authorizeGelato = async () => {\n  return await abiEncodeWithSelector({\n    abi: [\"function add(address authority) payable \"],\n    functionname: \"add\",\n    inputs: [GELATO_CORE],\n  });\n};\n\nexport const submitRefinanceMakerToMaker = async (\n  user,\n  ratioLimit,\n  minColRatio,\n  vaultAId,\n  vaultBId\n) => {\n  const userProxy = await getUserProxyContract(user);\n  //#region Condition Vault is Safe\n\n  const conditionMakerVaultUnsafeObj = new Condition({\n    inst: CONDITION_VAULT_IS_SAFE_ADDR,\n    data: await abiEncodeWithSelector({\n      abi: [\n        \"function isVaultUnsafe(uint256 _vaultId, address _priceOracle, bytes _oraclePayload, uint256 _minColRatio) view returns (string)\",\n      ],\n      functionname: \"isVaultUnsafe\",\n      inputs: [\n        vaultAId,\n        PRICE_ORACLE_ADDR,\n        PRICE_ORACLE_MAKER_PAYLOAD,\n        minColRatio,\n      ],\n    }),\n  });\n\n  //#endregion Condition Vault is Safe\n\n  //#region Condition Borrow Amount is dust\n\n  const conditionBorrowAmtIsDust = new Condition({\n    inst: CONDITION_BORROW_AMOUNT_IS_DUST,\n    data: await abiEncodeWithSelector({\n      abi: [\n        \"function isBorrowAmountDust(address _dsa, uint256 _fromVaultId, uint256 _destVaultId, string memory _destColType) view returns (string)\",\n      ],\n      functionname: \"isBorrowAmountDust\",\n      inputs: [userProxy.address, vaultAId, vaultBId, \"ETH-B\"],\n    }),\n  });\n\n  //#endregion Condition Borrow Amount is dust\n\n  //#region Condition Borrow Amount is dust\n\n  const conditionDebtCeilingIsReached = new Condition({\n    inst: CONDITION_DEBT_CEILING_IS_REACHED,\n    data: await abiEncodeWithSelector({\n      abi: [\n        \"function isDebtCeilingReached(address _dsa, uint256 _fromVaultId, uint256 _destVaultId, string memory _destColType) view returns (string)\",\n      ],\n      functionname: \"isDebtCeilingReached\",\n      inputs: [userProxy.address, vaultAId, vaultBId, \"ETH-B\"],\n    }),\n  });\n\n  //#endregion Condition Borrow Amount is dust\n\n  //#region Condition Debt Bridge is Affordable\n\n  const conditionDebtBridgeIsAffordableObj = new Condition({\n    inst: CONDITION_DEBT_BRIDGE_AFFORDABLE_ADDR,\n    data: await abiEncodeWithSelector({\n      abi: [\n        \"function isAffordable(uint256 _vaultId, uint256 _ratioLimit) view returns (string)\",\n      ],\n      functionname: \"isAffordable\",\n      inputs: [vaultAId, ratioLimit],\n    }),\n  });\n\n  //#endregion Condition Debt Bridge is Affordable\n\n  //#region Condition is Vault B Will be Safe\n\n  const conditionIsDestVaultWillBeSafeObj = new Condition({\n    inst: CONDITION_DEBT_VAULT_WILL_BE_SAFE,\n    data: await abiEncodeWithSelector({\n      abi: [\n        \"function destVaultWillBeSafe(address _dsa, uint256 _fromVaultId, uint256 _destVaultId, string memory _destColType) view returns (string)\",\n      ],\n      functionname: \"destVaultWillBeSafe\",\n      inputs: [userProxy.address, vaultAId, vaultBId, \"ETH-B\"],\n    }),\n  });\n\n  //#endregion Condition is Vault B Will be Safe\n\n  //#region Action Call Connector For Full Refinancing\n\n  const debtBridgeCalculationForFullRefinanceAction = new Action({\n    addr: CONNECT_FULL_REFINANCE_ADDR,\n    data: await abiEncodeWithSelector({\n      abi: [\n        \"function getDataAndCastMakerToMaker(uint256 _vaultAId, uint256 _vaultBId, address _colToken, string _colType) payable\",\n      ],\n      functionname: \"getDataAndCastMakerToMaker\",\n      inputs: [vaultAId, vaultBId, ETH, \"ETH-B\"],\n    }),\n    operation: Operation.Delegatecall,\n    termsOkCheck: true,\n  });\n\n  //#endregion Action Call Connector For Full Refinancing\n\n  //#region Debt Bridge Task Creation\n\n  const debtBridgeTask = new Task({\n    conditions: [\n      conditionMakerVaultUnsafeObj,\n      conditionDebtBridgeIsAffordableObj,\n      conditionIsDestVaultWillBeSafeObj,\n      conditionBorrowAmtIsDust,\n      conditionDebtCeilingIsReached,\n    ],\n    actions: [debtBridgeCalculationForFullRefinanceAction],\n  });\n\n  getTaskHash(debtBridgeTask);\n\n  //#endregion Debt Bridge Task Creation\n\n  //#region Gelato Connector call cast\n\n  const gelatoExternalProvider = new GelatoCoreLib.GelatoProvider({\n    addr: EXTERNAL_PROVIDER_ADDR, // Gelato Provider Address\n    module: PROVIDER_DSA_MODULE_ADDR, // Gelato DSA module\n  });\n\n  return await abiEncodeWithSelector({\n    abi: ConnectGelato,\n    functionname: \"submitTask\",\n    inputs: [gelatoExternalProvider, debtBridgeTask, 0],\n  });\n\n  //#endregion Gelato Connector call cast\n};\n\nexport const getTaskHash = (task) => {\n  const conditionsWithoutData = [];\n  for (let condition of task.conditions) {\n    conditionsWithoutData.push(condition.inst);\n  }\n  const actionsWithoutData = [];\n  for (let action of task.actions) {\n    actionsWithoutData.push({\n      addr: action.addr,\n      operation: parseInt(action.operation),\n      dataFlow: parseInt(action.dataFlow),\n      value: parseInt(action.value) === 0 ? false : true,\n      termsOkCheck: action.termsOkCheck,\n    });\n  }\n  const encodedData = ethers.utils.defaultAbiCoder.encode(\n    [\n      \"address[] conditionAddresses\",\n      \"tuple(address addr, uint8 operation, uint8 dataFlow, bool value, bool termsOkCheck)[] noDataActions\",\n    ],\n    [conditionsWithoutData, actionsWithoutData]\n  );\n\n  const taskIdentifier = ethers.utils.keccak256(encodedData);\n  console.log(taskIdentifier);\n\n  return taskIdentifier;\n};\n\nexport const getCancelTaskData = async (taskReceipt) => {\n  const iGelatoHandler = new ethers.utils.Interface([\n    \"function multiCancelTasks(tuple(uint256 id, address userProxy, tuple(address addr, address module) provider, uint256 index, tuple(tuple(address inst, bytes data)[] conditions, tuple(address addr, bytes data, uint8 operation, uint8 dataFlow, uint256 value, bool termsOkCheck)[] actions, uint256 selfProviderGasLimit, uint256 selfProviderGasPriceCeil)[] tasks, uint256 expiryDate, uint256 cycleId, uint256 submissionsLeft)[] _TasksToCancel)\",\n  ]);\n  return iGelatoHandler.encodeFunctionData(\"multiCancelTasks\", [[taskReceipt]]); // array of taskReceipts\n};\n"]},"metadata":{},"sourceType":"module"}