{"ast":null,"code":"import { ethers } from \"ethers\";\nimport { addresses, abis } from \"@gelato-krystal/contracts\";\nimport { GelatoCore } from \"@gelatonetwork/core\";\nimport { TASK_HASH } from \"./constants\";\nconst {\n  MULTI_SEND,\n  GELATO_CORE\n} = addresses;\nexport const getMiniAddress = account => {\n  return `${account.substring(0, 6)}...${account.substring(38, 42)}`;\n};\nexport const getGasNowGasPrice = async () => {\n  let url = `https://www.gasnow.org/api/v3/gas/price?utm_source=:GELATINO`;\n\n  try {\n    const response = await fetch(url);\n    const gasNowJson = await response.json();\n    return gasNowJson.data.fast;\n  } catch (error) {}\n}; // operation\n// address\n// value\n// data\n\nexport const encodeMultiSend = (transactions, signer) => {\n  const multisendAbi = [\"function multiSend(bytes transactions) payable\"];\n  const multiSend = new ethers.Contract(MULTI_SEND, multisendAbi, signer);\n  let multiSendData = [];\n  transactions.forEach(tx => {\n    const hashedMultiSendData = ethers.utils.solidityPack([\"uint8\", \"address\", \"uint256\", \"uint256\", \"bytes\"], [tx.operation, // Operation\n    tx.address, //to\n    tx.value, // value\n    ethers.utils.hexDataLength(tx.data), // data length\n    tx.data // data\n    ]);\n    multiSendData.push(hashedMultiSendData);\n  });\n  const hexlifiedData = ethers.utils.hexlify(ethers.utils.concat(multiSendData));\n  const encodedMultiSendData = multiSend.interface.encodeFunctionData(\"multiSend\", [hexlifiedData]);\n  return encodedMultiSendData;\n};\nexport const getTaskHash = task => {\n  const conditionsWithoutData = [];\n\n  for (let condition of task.conditions) {\n    conditionsWithoutData.push(condition.inst);\n  }\n\n  const actionsWithoutData = [];\n\n  for (let action of task.actions) {\n    actionsWithoutData.push({\n      addr: action.addr,\n      operation: parseInt(action.operation),\n      dataFlow: parseInt(action.dataFlow),\n      value: parseInt(action.value) == 0 ? false : true,\n      termsOkCheck: action.termsOkCheck\n    });\n  }\n\n  const encodedData = ethers.utils.defaultAbiCoder.encode([\"address[] conditionAddresses\", \"tuple(address addr, uint8 operation, uint8 dataFlow, bool value, bool termsOkCheck)[] noDataActions\"], [conditionsWithoutData, actionsWithoutData]);\n  const taskIdentifier = ethers.utils.keccak256(encodedData);\n  return taskIdentifier;\n}; // Returns true if task correspons to certain Task Hashes\n\nexport const isKnownTask = task => {\n  return getTaskHash(task) === TASK_HASH;\n};\nexport const sleep = ms => {\n  return new Promise(resolve => {\n    // console.log(`\\n\\tSleeping for ${ms / 1000} seconds\\n`);\n    setTimeout(resolve, ms);\n  });\n};\nexport const abiEncodeWithSelector = async args => {\n  let iface = new ethers.utils.Interface(args.abi);\n  return iface.encodeFunctionData(args.functionname, args.inputs);\n};\nexport const getFormattedNumber = async val => {\n  if (ethers.utils.parseUnits(\"1\", 16).gt(val)) return 0;\n  return getFormattedToFixed2(ethers.utils.formatUnits(val, \"18\"));\n};\nexport const getFormattedToFixed2 = val => {\n  return parseFloat(val).toFixed(2);\n};\nexport const getABICoder = () => {\n  return new ethers.utils.AbiCoder();\n};\nexport const toPercentFormat = percent => {\n  return getFormattedToFixed2(percent) + \"%\";\n};\nexport const getDisplayablePercent = val => {\n  return val.mul(ethers.BigNumber.from(\"100\")).div(ethers.utils.parseUnits(\"1\", 18));\n};\nexport const decodeWithoutSignature = (valueTypes, data) => {\n  return getABICoder().decode(valueTypes, \"0x\" + String(data).substring(10));\n};","map":{"version":3,"sources":["/Users/Hilmar/code/integrations/krystal/gelato-krystal/packages/react-app/src/utils/helpers.js"],"names":["ethers","addresses","abis","GelatoCore","TASK_HASH","MULTI_SEND","GELATO_CORE","getMiniAddress","account","substring","getGasNowGasPrice","url","response","fetch","gasNowJson","json","data","fast","error","encodeMultiSend","transactions","signer","multisendAbi","multiSend","Contract","multiSendData","forEach","tx","hashedMultiSendData","utils","solidityPack","operation","address","value","hexDataLength","push","hexlifiedData","hexlify","concat","encodedMultiSendData","interface","encodeFunctionData","getTaskHash","task","conditionsWithoutData","condition","conditions","inst","actionsWithoutData","action","actions","addr","parseInt","dataFlow","termsOkCheck","encodedData","defaultAbiCoder","encode","taskIdentifier","keccak256","isKnownTask","sleep","ms","Promise","resolve","setTimeout","abiEncodeWithSelector","args","iface","Interface","abi","functionname","inputs","getFormattedNumber","val","parseUnits","gt","getFormattedToFixed2","formatUnits","parseFloat","toFixed","getABICoder","AbiCoder","toPercentFormat","percent","getDisplayablePercent","mul","BigNumber","from","div","decodeWithoutSignature","valueTypes","decode","String"],"mappings":"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","sourcesContent":["import { ethers } from \"ethers\";\nimport { addresses, abis } from \"@gelato-krystal/contracts\";\nimport { GelatoCore } from \"@gelatonetwork/core\";\n\nimport { TASK_HASH } from \"./constants\";\n\nconst { MULTI_SEND, GELATO_CORE } = addresses;\n\nexport const getMiniAddress = (account) => {\n  return `${account.substring(0, 6)}...${account.substring(38, 42)}`;\n};\n\nexport const getGasNowGasPrice = async () => {\n  let url = `https://www.gasnow.org/api/v3/gas/price?utm_source=:GELATINO`;\n  try {\n    const response = await fetch(url);\n    const gasNowJson = await response.json();\n    return gasNowJson.data.fast;\n  } catch (error) {}\n};\n\n// operation\n// address\n// value\n// data\nexport const encodeMultiSend = (transactions, signer) => {\n  const multisendAbi = [\"function multiSend(bytes transactions) payable\"];\n  const multiSend = new ethers.Contract(MULTI_SEND, multisendAbi, signer);\n  let multiSendData = [];\n  transactions.forEach((tx) => {\n    const hashedMultiSendData = ethers.utils.solidityPack(\n      [\"uint8\", \"address\", \"uint256\", \"uint256\", \"bytes\"],\n      [\n        tx.operation, // Operation\n        tx.address, //to\n        tx.value, // value\n        ethers.utils.hexDataLength(tx.data), // data length\n        tx.data, // data\n      ]\n    );\n    multiSendData.push(hashedMultiSendData);\n  });\n\n  const hexlifiedData = ethers.utils.hexlify(\n    ethers.utils.concat(multiSendData)\n  );\n\n  const encodedMultiSendData = multiSend.interface.encodeFunctionData(\n    \"multiSend\",\n    [hexlifiedData]\n  );\n\n  return encodedMultiSendData;\n};\n\nexport const getTaskHash = (task) => {\n  const conditionsWithoutData = [];\n  for (let condition of task.conditions) {\n    conditionsWithoutData.push(condition.inst);\n  }\n  const actionsWithoutData = [];\n  for (let action of task.actions) {\n    actionsWithoutData.push({\n      addr: action.addr,\n      operation: parseInt(action.operation),\n      dataFlow: parseInt(action.dataFlow),\n      value: parseInt(action.value) == 0 ? false : true,\n      termsOkCheck: action.termsOkCheck,\n    });\n  }\n  const encodedData = ethers.utils.defaultAbiCoder.encode(\n    [\n      \"address[] conditionAddresses\",\n      \"tuple(address addr, uint8 operation, uint8 dataFlow, bool value, bool termsOkCheck)[] noDataActions\",\n    ],\n    [conditionsWithoutData, actionsWithoutData]\n  );\n\n  const taskIdentifier = ethers.utils.keccak256(encodedData);\n\n  return taskIdentifier;\n};\n\n// Returns true if task correspons to certain Task Hashes\nexport const isKnownTask = (task) => {\n  return getTaskHash(task) === TASK_HASH;\n};\n\nexport const sleep = (ms) => {\n  return new Promise((resolve) => {\n    // console.log(`\\n\\tSleeping for ${ms / 1000} seconds\\n`);\n    setTimeout(resolve, ms);\n  });\n};\n\nexport const abiEncodeWithSelector = async (args) => {\n  let iface = new ethers.utils.Interface(args.abi);\n  return iface.encodeFunctionData(args.functionname, args.inputs);\n};\n\nexport const getFormattedNumber = async (val) => {\n  if (ethers.utils.parseUnits(\"1\", 16).gt(val)) return 0;\n\n  return getFormattedToFixed2(ethers.utils.formatUnits(val, \"18\"));\n};\n\nexport const getFormattedToFixed2 = (val) => {\n  return parseFloat(val).toFixed(2);\n};\n\nexport const getABICoder = () => {\n  return new ethers.utils.AbiCoder();\n};\n\nexport const toPercentFormat = (percent) => {\n  return getFormattedToFixed2(percent) + \"%\";\n};\n\nexport const getDisplayablePercent = (val) => {\n  return val\n    .mul(ethers.BigNumber.from(\"100\"))\n    .div(ethers.utils.parseUnits(\"1\", 18));\n};\n\nexport const decodeWithoutSignature = (valueTypes, data) => {\n  return getABICoder().decode(valueTypes, \"0x\" + String(data).substring(10));\n};\n"]},"metadata":{},"sourceType":"module"}