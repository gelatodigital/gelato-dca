{"ast":null,"code":"const Action = require(\"../../classes/gelato/Action\");\n\nconst Condition = require(\"../../classes/gelato/Condition\");\n\nconst GelatoProvider = require(\"../../classes/gelato/GelatoProvider\");\n\nconst Task = require(\"../../classes/gelato/Task\");\n\nconst TaskReceipt = require(\"../../classes/gelato/TaskReceipt\");\n/*\nstruct Provider {\n    address addr;  //  if msg.sender == provider => self-Provider\n    IGelatoProviderModule module;  //  can be IGelatoProviderModule(0) for self-Providers\n}\n\nstruct Condition {\n    IGelatoCondition inst;  // can be AddressZero for self-conditional Actions\n    bytes data;  // can be bytes32(0) for self-conditional Actions\n}\n\nenum Operation { Call, Delegatecall }\n\nstruct Action {\n    address addr;\n    bytes data;\n    Operation operation;\n    uint256 value;\n    bool termsOkCheck;\n}\n\n\n\nstruct TaskReceipt {\n    uint256 id;\n    address userProxy;\n    Task task;\n}\n */\n// Provider\n\n\nconst PROVIDER_ADDR = 0;\nconst PROVIDER_MODULE = 1; // Condition\n\nconst CONDITION_INST = 0;\nconst CONDITION_DATA = 1; // Action\n\nconst ACTION_ADDR = 0;\nconst ACTION_DATA = 1;\nconst OPERATION = 2;\nconst DATA_PIPE = 3;\nconst VALUE = 4;\nconst TERMS_OK_CHECK = 5; // Task\n\nconst CONDITIONS = 0;\nconst ACTIONS = 1;\nconst SELF_PROVIDER_GAS_LIMIT = 2;\nconst SELF_PROVIDER_GAS_PRICE_CEIL = 3; // TaskReceipt\n\nconst ID = 0;\nconst USER_PROXY = 1;\nconst PROVIDER = 2;\nconst INDEX = 3;\nconst TASKS = 4;\nconst EXPIRY_DATE = 5;\nconst CYCLE_ID = 6;\nconst SUBMISSIONS_LEFT = 7;\n\nfunction convertTaskReceiptArrayToObj(taskReceiptArray) {\n  const tasks = _convertToArrayOfTaskObjs(taskReceiptArray[TASKS]);\n\n  const taskReceiptObj = new TaskReceipt({\n    id: taskReceiptArray[ID],\n    userProxy: taskReceiptArray[USER_PROXY],\n    provider: _convertToProviderObj(taskReceiptArray[PROVIDER]),\n    index: taskReceiptArray[INDEX],\n    tasks: tasks ? tasks : [],\n    expiryDate: taskReceiptArray[EXPIRY_DATE],\n    cycleId: taskReceiptArray[CYCLE_ID],\n    submissionsLeft: taskReceiptArray[SUBMISSIONS_LEFT]\n  });\n  return taskReceiptObj;\n}\n\nfunction _convertToProviderObj(providerLog) {\n  const provider = new GelatoProvider({\n    addr: providerLog[PROVIDER_ADDR],\n    module: providerLog[PROVIDER_MODULE]\n  });\n  return provider;\n}\n\nfunction _convertToArrayOfTaskObjs(tasksLog) {\n  const tasks = [];\n\n  for (let task of tasksLog) {\n    task = new Task({\n      conditions: _convertToArrayOfConditionObjs(task[CONDITIONS]),\n      actions: _convertToArrayOfActionObjs(task[ACTIONS]),\n      selfProviderGasLimit: task[SELF_PROVIDER_GAS_LIMIT],\n      selfProviderGasPriceCeil: task[SELF_PROVIDER_GAS_PRICE_CEIL]\n    });\n    tasks.push(task);\n  }\n\n  return tasks;\n}\n\nfunction _convertToArrayOfConditionObjs(conditionsLog) {\n  const conditions = [];\n\n  for (let condition of conditionsLog) {\n    condition = new Condition({\n      inst: condition[CONDITION_INST],\n      data: condition[CONDITION_DATA]\n    });\n    conditions.push(condition);\n  }\n\n  return conditions;\n}\n\nfunction _convertToArrayOfActionObjs(actionsLog) {\n  const actions = [];\n\n  for (let action of actionsLog) {\n    action = new Action({\n      addr: action[ACTION_ADDR],\n      data: action[ACTION_DATA],\n      operation: action[OPERATION],\n      dataFlow: action[DATA_PIPE],\n      value: action[VALUE],\n      termsOkCheck: action[TERMS_OK_CHECK]\n    });\n    actions.push(action);\n  }\n\n  return actions;\n}\n\nmodule.exports = convertTaskReceiptArrayToObj;","map":{"version":3,"sources":["/Users/Hilmar/code/integrations/krystal/gelato-krystal/node_modules/@gelatonetwork/core/src/helpers/gelato/convertTaskReceiptArrayToObj.js"],"names":["Action","require","Condition","GelatoProvider","Task","TaskReceipt","PROVIDER_ADDR","PROVIDER_MODULE","CONDITION_INST","CONDITION_DATA","ACTION_ADDR","ACTION_DATA","OPERATION","DATA_PIPE","VALUE","TERMS_OK_CHECK","CONDITIONS","ACTIONS","SELF_PROVIDER_GAS_LIMIT","SELF_PROVIDER_GAS_PRICE_CEIL","ID","USER_PROXY","PROVIDER","INDEX","TASKS","EXPIRY_DATE","CYCLE_ID","SUBMISSIONS_LEFT","convertTaskReceiptArrayToObj","taskReceiptArray","tasks","_convertToArrayOfTaskObjs","taskReceiptObj","id","userProxy","provider","_convertToProviderObj","index","expiryDate","cycleId","submissionsLeft","providerLog","addr","module","tasksLog","task","conditions","_convertToArrayOfConditionObjs","actions","_convertToArrayOfActionObjs","selfProviderGasLimit","selfProviderGasPriceCeil","push","conditionsLog","condition","inst","data","actionsLog","action","operation","dataFlow","value","termsOkCheck","exports"],"mappings":"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","sourcesContent":["const Action = require(\"../../classes/gelato/Action\");\nconst Condition = require(\"../../classes/gelato/Condition\");\nconst GelatoProvider = require(\"../../classes/gelato/GelatoProvider\");\nconst Task = require(\"../../classes/gelato/Task\");\nconst TaskReceipt = require(\"../../classes/gelato/TaskReceipt\");\n\n/*\nstruct Provider {\n    address addr;  //  if msg.sender == provider => self-Provider\n    IGelatoProviderModule module;  //  can be IGelatoProviderModule(0) for self-Providers\n}\n\nstruct Condition {\n    IGelatoCondition inst;  // can be AddressZero for self-conditional Actions\n    bytes data;  // can be bytes32(0) for self-conditional Actions\n}\n\nenum Operation { Call, Delegatecall }\n\nstruct Action {\n    address addr;\n    bytes data;\n    Operation operation;\n    uint256 value;\n    bool termsOkCheck;\n}\n\n\n\nstruct TaskReceipt {\n    uint256 id;\n    address userProxy;\n    Task task;\n}\n */\n\n// Provider\nconst PROVIDER_ADDR = 0;\nconst PROVIDER_MODULE = 1;\n\n// Condition\nconst CONDITION_INST = 0;\nconst CONDITION_DATA = 1;\n\n// Action\nconst ACTION_ADDR = 0;\nconst ACTION_DATA = 1;\nconst OPERATION = 2;\nconst DATA_PIPE = 3;\nconst VALUE = 4;\nconst TERMS_OK_CHECK = 5;\n\n// Task\nconst CONDITIONS = 0;\nconst ACTIONS = 1;\nconst SELF_PROVIDER_GAS_LIMIT = 2;\nconst SELF_PROVIDER_GAS_PRICE_CEIL = 3;\n\n// TaskReceipt\nconst ID = 0;\nconst USER_PROXY = 1;\nconst PROVIDER = 2;\nconst INDEX = 3;\nconst TASKS = 4;\nconst EXPIRY_DATE = 5;\nconst CYCLE_ID = 6;\nconst SUBMISSIONS_LEFT = 7;\n\nfunction convertTaskReceiptArrayToObj(taskReceiptArray) {\n  const tasks = _convertToArrayOfTaskObjs(taskReceiptArray[TASKS]);\n\n  const taskReceiptObj = new TaskReceipt({\n    id: taskReceiptArray[ID],\n    userProxy: taskReceiptArray[USER_PROXY],\n    provider: _convertToProviderObj(taskReceiptArray[PROVIDER]),\n    index: taskReceiptArray[INDEX],\n    tasks: tasks ? tasks : [],\n    expiryDate: taskReceiptArray[EXPIRY_DATE],\n    cycleId: taskReceiptArray[CYCLE_ID],\n    submissionsLeft: taskReceiptArray[SUBMISSIONS_LEFT],\n  });\n\n  return taskReceiptObj;\n}\n\nfunction _convertToProviderObj(providerLog) {\n  const provider = new GelatoProvider({\n    addr: providerLog[PROVIDER_ADDR],\n    module: providerLog[PROVIDER_MODULE],\n  });\n  return provider;\n}\n\nfunction _convertToArrayOfTaskObjs(tasksLog) {\n  const tasks = [];\n  for (let task of tasksLog) {\n    task = new Task({\n      conditions: _convertToArrayOfConditionObjs(task[CONDITIONS]),\n      actions: _convertToArrayOfActionObjs(task[ACTIONS]),\n      selfProviderGasLimit: task[SELF_PROVIDER_GAS_LIMIT],\n      selfProviderGasPriceCeil: task[SELF_PROVIDER_GAS_PRICE_CEIL],\n    });\n    tasks.push(task);\n  }\n  return tasks;\n}\n\nfunction _convertToArrayOfConditionObjs(conditionsLog) {\n  const conditions = [];\n  for (let condition of conditionsLog) {\n    condition = new Condition({\n      inst: condition[CONDITION_INST],\n      data: condition[CONDITION_DATA],\n    });\n    conditions.push(condition);\n  }\n  return conditions;\n}\n\nfunction _convertToArrayOfActionObjs(actionsLog) {\n  const actions = [];\n  for (let action of actionsLog) {\n    action = new Action({\n      addr: action[ACTION_ADDR],\n      data: action[ACTION_DATA],\n      operation: action[OPERATION],\n      dataFlow: action[DATA_PIPE],\n      value: action[VALUE],\n      termsOkCheck: action[TERMS_OK_CHECK],\n    });\n    actions.push(action);\n  }\n  return actions;\n}\n\nmodule.exports = convertTaskReceiptArrayToObj;\n"]},"metadata":{},"sourceType":"script"}